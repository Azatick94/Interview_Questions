

<h1>*** Core JAVA</h1>
---
<h2>* Парадигмы программирования</h2>
<p>* Объектно-ориентированное программирование. Наиболее распространённая на данный момент парадигма. Это подвид императивного программирования — оно основано на последовательных вызовах команд, изменяющих данные, с которыми работает программа. Таким образом она оперирует объектами, и это удобно для многих приложений.</p>
<p>* Функциональное программирование. По распространённости функциональная парадигма программирования занимает второе место после ООП. В ФП код программы состоит из функций, для которых подробно прописано, что должно быть на входе, а что — на выходе. Причём одну функцию вполне можно подать на вход другой в качестве аргумента. Так программа выполняется, запуская нужные функции. Преимущества функционального подхода — в том, что код легко читать, а тестирование упрощается.</p>
<p>* Cуществуют и другие парадигмы, но они менее распространены. Например - Императивное программирование (программирование инструкциями). То есть это машинные коды, языки ассемблера и ранние высокоуровневые языки, вроде Fortran. </p>
<p>* Структурное программирование - это уже объединение часто используемого императивного кода в шаблоны. </p>


---
<h2>* Критерии качества кода? </h2>
* соответствие правилам;<br>
* сложность кода;<br>
* дубликаты;<br>
* комментирование;<br>
* покрытие тестами.<br>
<p>1. Соответствие правилам. Java Code Conventions, GCC Coding Conventions, Zends Coding Standard. синтаксические правила — одни из наиболее бесполезных правил (но только первый взгляд), поскольку совсем никоим образом не виляют на исполнение программы. К ним можно отнести стиль именования переменных (camelCase, через подчеркивание), констант (uppercase), методов, стиль написания фигурных скобок и нужны ли они если в блоке только одна строка кода.  </p>
<p>2. Цикломатическая сложность код. Классы не должны быть слишком длинными, должны быть читаемы. То есть измеряется сложностью метода, класса, файла. </p>
<p>3. Дубликаты. Важная характеристика, которая отображает насколько легко в будущем (или настоящим) можно будет вносить изменения в код. Метрику можно означить в процентах как соотношение строк дубликатов к всем строкам кода. Чем меньше дубликатов тем легче будет жить с этим кодом.</p>
<p>4. Комментирование. ЗАвисит от по большей части от правил компании, от соглашений программистов. Для маленьких проектов комментирование не столь необходимо, для больших же хорошо проработанные правила очень облегчат сопровождение.  </p>
<p>5. Покрытие тестами. Чем выше покрытие кода тестами тем меньше риск поломать часть системы и оставить это незамеченным.</p>


---
<h2>* CI/CD. Что это? Как работает?</h2>
Это методика разработки и интеграции приложения.
CI/CD - Continuous Intergration, Continuous Delivery.  <br>
CI/CD-платформы, на базе которых реализуется концепция, поддерживают выполнение регулярной автоматизированной сборки проекта для оперативного выявления дефектов и решения интеграционных проблем. 
<br>
Автоматизированные процессы помогают значительно снизить трудозатраты разных отделов предприятия. Без автоматизации CI/CD могут всплывать ошибки, вызванные человеческим фактором и необходимостью совершения ручных операций.


---
<h2>* Методы Object.</h2>
<p>getClass, hashCode (возвращает адрес объекта в памяти), equals, clone, toString, notify, notifyAll, wait, finalize</p>

---
<h2>* Модификаторы доступа</h2>
* private ( область действия класса);<br>
* default, package-default (область действия внутри пакета) <br>
* protected (область действия внутри пакета + наследники); 
* public (доступ везде); 

---
<h2>* Принципы ООП. </h2>
* Абстракция <br>
Если посмотреть на самый современный и на самый первый телефон, можно сразу выделить самые важные детали, которые важны и для устройства конца 19-го века, и для суперсовременного смартфона. Это совершение вызова (набор номера) и приём вызова. По сути это то, что делает телефон телефоном, а не чем-то другим. Сейчас мы применили принцип в ООП — выделение наиболее важных характеристик и информации об объекте. Этот принцип ООП называется абстракцией.<br>
* Инкапсуляция <br>
Для исключения подобного вмешательства в конструкцию и работу объекта в ООП используют принцип инкапсуляции – еще один базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс.
* Наследование <br>
В программировании наследование заключается в использовании уже существующих классов для описания новых. Использование принципа наследование ООП позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту.
* Полиморфизм <br>
Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта, называется полиморфизмом.

---
<h2>* На какие области делится память JVM</h2>

* Stack <br>
Хранит примитивы, ссылки на объекты, хранит локальные переменные. <br>
Из-за простоты распределния памяти, стековая память работает немного быстрее хипа. Размер меньше, чем у Heap. 
* Data Heap <br>
Динамически распределе. опер. память. RAM. Используется для JRE классов и размещения объектов. 

---
<h2>* Чем отличается JRE, JVM, JDK</h2>

<p>JRE - Java RunTime Environment. Минимальная реализация виртуальной машины, необходимая для исполнения Java приложений, без компилятора и т.д. Состоит из виртуальной машины - JVM и библиотек Java-классов</p>
<p>JVM - Java Virtual Machine. JVM -  основная часть JRE. Виртуальная машина интерпретирует байт код. </p>
<p>JDK - Java Development kit. Комплект разработчика на Java, включает javac, стандартные библиотеки, документацию, примеры + JRE для запуска написанных программ.</p>

---
<h2>* Для чего в джава статические блоки? </h2>
<p>Статические блоки в джава выполняются до выполнения конструктора , с помощью них инициализуют статические поля например</p>

---
<h2>* Что такое перегрузка методов? Можно ли перегрузить static методы?</h2>
<p>В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).</p>
<p>Статические методы можно перегружать нестатическими и обратно - без ограничений. </p>

---
<h2>* Приведите пример когда можно использовать статический метод?</h2>
<p>Статические методы применяются например для инициализации статических переменных. </p>

---
<h2>* Что такое загрузчик классов в Java? Какие бывают? Статическая и динамическая загрузка классов? </h2>
Загрузчик классов используется для поставки в JVM скомпилированного байт-кода, который, как правило, хранится в файлах с расширением .class<br>
Реализуя наследников ClassLoader, можно полностью контролировать процесс загрузки абсолютно всех Java-классов. <br>
Можно загружать их из любого источника, к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из базы данных или из Internet. <br>
Можно предоставить загрузку стандартных библиотечных классов системному загрузчику, но при этом протоколировать факт обращения к ним. <br>

Бывают 3 типа загрузчиков<br>
* Базовый загрузчик - загружает стандартные классы JDK из архива rt.jar<br>
* Загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут быть заданы системным свойством java.ext.dirs <br>
* Системный загрузчик - загружает классы приложения, определенные в переменной среды окружения CLASSPATH. 

Загрузчик расширений и системный загрузчик наследуют абстрактный класс ClassLoader. Базовый загрузчик уже реализован нативно внутри Java.<br>
ClassLoader - самый низкоуровневый, «глубинный» механизм Java, позволяющий вмешиваться практически в ядро Java-машины, причем оставаясь в рамках программирования на Java.
<br>
Реализуя наследников ClassLoader, можно полностью контролировать процесс загрузки абсолютно всех Java-классов. Можно загружать их из любого источника, к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из базы данных или из Internet. 

<br><br>
<i>Статическая загрузка класса </i> происходит при использовании оператора "new"<br>
<i>Динамическая загрузка класса </i> происходит на лету, с помощью статического метода класса Class.forname(имя класса). Динамическая загрузка нужна когда нужен неизвестный класс(то есть еще сам класс еще не определен), и загрузка это класс происходит в ходе выполнения программы. 

---
<h2>* Статический класс. Особенности</h2>
<p>
    Статическим классом может быть только класс внутри класса. 
</p>

---
<h2>* Каким образом передаются переменные в методы, по значению или по ссылке?</h2>
<p>В java переменные в методы передаются по значению. То есть создаются копии параметров и работа происходит с ними. </p>
<p>При передачи объекта копируется ссылка на него. И если в методы мы изменим состояние объета, то и за методом это состояние объекта изменится. Однако если мы изменим ссылку на объект, то то старая ссылка не изменится. </p>

---
<h2>* Расскажите про клонирование объектов. В чем отличие поверхностного от глубокого клонирования? </h2>
<p>Чтобы объект можно было клонировать, необходимо реализовать интерфейс Cloneable (маркер). </p>
<p>Поверхностное клонирование - клонируются только примитивные поля, ссылочные поля не клонируются</p>
<p>Глубокое клонирование - клонируются еще ссылкы. Для этого необходимо переопределить метод clone и в нем произвести клонирование изменяемых полей объекта. </p>

---
<h2>* Какие виды исключений вы знаете? Checked vs unchecked Exceptions?</h2> 
<i>unchecked exception</i> - наследники классов Error и RunTimeException, <br>
<i>checked exception</i> - наследники Throwable и Exception.
<br><br>
Примеры unchecked exception Error: OutOfMemoryError, StackOverFlowError, LinkageError<br>
Примеры unchecked exception RunTimeException: IndexOutOfBoundsException, ArithmeticException, IllegalArgumentException<br>
Примеры checked exception Exception: IO Exception (FileNotFoundException), SocketException<br>

<br>
Что значит “проверяемые”? ...компилятор Java знает о самых распространенных исключениях, и знает, в каких ситуациях они могут возникнуть”. Поэтому компилятор заранее проверяет наш код на наличие потенциальных исключений. Если он их найдет, то не скомпилирует код, пока мы не обработаем их или не пробросим наверх. Поэтому они проверяемые. 
<br>
Непроверяемые исключения.  компилятор явно не в силах предусмотреть все возможные неправильные ситуации, которые люди могут создать своими руками :) Поэтому он не будет проверять обработку таких исключений в нашем коде. Поэтому непроверяемые. 

---
<h2>* Может ли абстрактный класс быть final? </h2>
Нет, не может. Ключевое слово final означает, что класс на вершине иерархии, и у него не может быть наследников. А абстрактный класс без наследников — это сферический конь в вакууме, так как нельзя создать экземпляр abstract class.

Таким образом, если класс одновременно abstract и final, то у него нет наследников и нельзя создать его экземпляр.
Компилятор Java выдаст ошибку, если сделать класс одновременно abstract и final.
4. Могут ли у абстрактного класса в языке Java быть статич


---
<h2>* Могут ли у абстрактного класса в языке Java быть статические методы? Можно ли переопрелять статические методы? </h2>
Да, абстрактные классы могут объявлять и определять статические методы. Только необходимо следовать общим принципам создания статических методов в Java, поскольку они нежелательны при объектно-ориентированном проектировании, ведь переопределение статических методов в Java невозможно. 
Однако вместо переопределения можно скрывать статические методы. 

---
<h2>* Что такое абстрактный метод?</h2>
Абстрактный метод – это метод без тела. Вы просто объявляете метод, не определяя его, с использованием ключевого слова abstract в объявлении метода. Все объявленные внутри интерфейса в языке Java методы – по умолчанию абстрактные. Вот пример абстрактного метода в языке Java:

---
<h2>* Может ли абстрактный класс в Java содержать метод main?</h2>
Да, абстрактный класс в Java может содержать метод main, ведь это просто еще один статический метод, и абстрактный класс можно выполнять при помощи метода main, если не создавать его экземпляров.



---
<h2>* Основные интерфейсы коллекций и их имплементации. </h2>
* Основные интерфейсы: List, Set, Queue; Map в коллекциям не относится, т.к. это совокупность пар ключ-значение.  
<br>
List: имеет следующие реализации: ArrayList (удобна в навигации), LinkedList (быстра в вставке и удалению элементов), Vector(синхронизован. работает медленнее в одном потоке.); 
<br>
Set: HashSet (упорядочивание по хэш-ключам), TreeSet (упорядоченный сет), LinkedHashSet (хранит элементы в порядке их добавления);
<br>
Queue: PriorityQueue; 
<br>
Map: HashTable (синхронизована, уже устаревшая), HashMap (порядок по хэш ключу), HashTree (порядок в отсортированном порядке), LinkedHashMap( в порядке вставки), ConcurrentHashMap (потокобезопасный map).


---
<h2>* ArrayList vs LinkedList</h2>
<p> В <i>LinkedList</i> элементы фактически представляют собой звенья одной цепи. У каждого элемента помимо тех данных, которые он хранит, имеется ссылка на предыдущий и следующий элемент. По этим ссылкам можно переходить от одного элемента к другому. </p>

Вся работа с ArrayList (по большому счету) сводится к работе с внутренним массивом. 
Вся работа с LinkedList сводится к изменению ссылок.

Общие методы: add(), remove(), indexOf(), clear(), contains(), size().
Методы только у LinkedList: addFirst(), addLast() - методы для добавления элемента в начало/конец списка. 

---
<h2>* Интерфейс Queue</h2>
Интерфейс Queue расширяет Collection и объявляет поведение очередей, которые представляют собой список с дисциплиной "первый вошел, первый вышел" (FIFO). Существуют разные типы очередей, в которых порядок основан на некотором критерии. 
FIFO - First In, First Out; 

---
<h2>* BlockingQueue </h2>
Интерфейс BlockingQueue наследует свойства интерфейса Queue; 

Реализация данного интерфейса обеспечивает блокировку потока в двух случаях:<br>
Когда поток пытается получить элемент из пустой очереди, то он переводится в состояние ожидания до тех пор, пока какой-либо другой поток не разместит элемент в очереди. 

Аналогично при попытке положить элемент в полную очередь; поток ставится в ожидание до тех пор, пока другой поток не заберет элемент из очереди и, таким образом, не освободит место в ней. Естественно, понятие "полная очередь" подразумевает ограничение размера очереди.
BlockingQueue изящно решает проблему передачи собранных одним потоком элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.

---
<h2>* ConcurrentHashMap vs HashMap</h2>
<p>
ConcurrentHashMap был представлен как альтернатива Hashtable в Java 1.5 как часть пакета многопоточности. C ConcurrentHashMap у вас есть лучший выбор, не только потому, что это безопасно в многопоточном окружении, но так же предоставляет лучшую производительность по сравнению с Hashtable и synchronizedMap. ConcurrentHashMap работает производительнее, потому что блокирует лишь часть Map. Позволяет одновременные операции чтения и в тоже время обеспечивает целостность, синхронизируя операции записи.
ConcurrentHashMap отлично подходит, когда у вас множество читающих потоков и несколько пишущих. 
</p>

---
<h2>* Comparable and Comparator</h2>
Comparable - если хотим сравнивать объекты, то достаточно заимплементить интерфейс Comparable в классе и переопределить метод compareTo.<br> 
Comparator - это отдельный класс Компаратора, в котором описывается вся логика сравнения объектов. Компаратор позваляет сохранять исходный код объекта, не изменять default метод сортировки. Очень удобно.
<br>
<a href="https://javarush.ru/groups/posts/2262-comparator-v-java?post=full#discussion">Полезная ссылка</a>

---
<h2>* Что такое сокет. Класс Socket. Для чего нужен? </h2>
Сокет нужен для получения соединения между двумя машинами. Например, чтобы получить связь между клиентом и сервером. 
Одна сторона считывает данные, другая сторона записывает данные и наоборот. 
Class Socket имплементит интерфейс Closeable (то есть через метод close можно закрыть соединение между клиентом и сервером). 

---
<h2>*Stream API и лямбда выражения в Java</h2>
<a href='https://java-master.com/stream-and-lambda-in-java/'>Link</a>
<p>
Лямбда — выражение в программировании — специальный синтаксис для определения функциональных объектов, заимствованный из лямбда-исчисления. То есть, используя функциональные объекты, можно объявлять функции в любом месте кода. Stream API в Java8 используется для работы с коллекциями, позволяя писать код в функциональном стиле.<br>
В мире Java они появились в 8 версии и не остались незамеченными опытными программистами. Их очень хорошо применять Stream API.
</p>
Порядок работы с лямбда выражениями:<br>
* создать stream; <br>
* выполнить цепочку операций со stream (промежуточные операции - их еще называют lazy операции);<br>
* выполнить терминальную операцию (объединение коллекций, агрегирование и т.д);<br>
Во время использования лямбда выражений можно пользоваться промежуточные операциями бесчисленное множество раз. Терминальная операция может быть использована один раз.<br>

Примеры создания stream-а: 
<p>Пустой стрим: Stream.empty()</p>
<p>Стрим из List: list.stream()</p>
<p>Стрим из Map: map.entrySet().stream()</p>
<p>Стрим из массива: Arrays.stream(array)</p>
<p>Стрим из указанных элементов: Stream.of("1", "2", "3")</p>

<a href="https://habr.com/ru/company/luxoft/blog/270383/">Очень полезная ссылка</a><br>
Основные промежуточные операции лямбда выражений.
* filter - фильтрация записей. 
* skip - пропуск N записей. 
* distinct - убирает дубликаты. 
* map - выполнение операций над каждым элементом стрима. 
* limit - ограничение выборки. 
* sorted- сортировка значений либо в натуральном порядке, либо с применением Comparator. 
* mapToInt, mapToDouble, mapToLong - аналог map, но возвращает числовой стрим.

Основные терминальные операции лямбда выражений. 
* findFirst - возвращает первый элемент. 
* collect - представление результата в виде коллекций или других структур данных. 
* сount - возвращает кол-во элементов. 
* anyMatch - возращает true если условие выполняется хотя бы для одного элемента. 
* noneMatch - возращает true если условие не выполняется для всех элементов.
* min, max - минимальное и максимальное значение. 
* forEach - применение функции к каждому элементу стрима. Порядок не гарантируется. 
* forEachSorted - применение функции к каждому элементу стрима c сохранением порядка. 
* reduce - позволяет выполнять агрегатные функции и возвращает один результат. (Пример: https://www.baeldung.com/java-stream-reduce)


---
<h2>* Внутренние классы</h2>
Эти классы создаются внутри других классов. 

Виды:
* Non-static nested classes — нестатические вложенные классы. 
* Static nested classes — статические вложенные классы.

В свою очередь, внутренние классы (inner classes) имеют два особых подвида. Помимо того, что внутренний класс может быть просто внутренним классом, он еще бывает:
локальным классом (local class)
анонимным классом (anonymous class)

--- 
<h2>* Try with resources</h2>

Try with resources был представлен в 7 версии Java. 
Позваляет использовать ресурсы в блоке try c гарантией того что после блока try ресурсы будут закрыты. 
Ресурсы должны обязательно имплементировать интерфейс AutoCloseable. 

Пример
<b>
try (Scanner scanner = new Scanner(new File("test.txt"))) { <br>
    while (scanner.hasNext()) {<br>
        System.out.println(scanner.nextLine());<br>
    }<br>
} catch (FileNotFoundException fnfe) {<br>
    fnfe.printStackTrace();<br>
}<br>
</br>
</b>

---
<h2>* Autoboxing. Что это? Особенности Autoboxing. </h2>
Autoboxing - автоупаковка, unboxing - распаковка. Autoboxing был внесен в JDK 5. <br>
<b>Автоупаковка</b> - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обертку всякий раз, когда это требуется.<br>
То есть int -> Integer, double -> Double, char -> Character, boolean -> Boolean. <br>
<b>Автораспаковка</b> - это обратный процесс. Преобразование класса-обертки в примитивный тип.<br>
При автораспаковке может произойти исключение java.lang.NullPointerException в случае если значение класса-обертки было = null. 

Старый способ получения примитивного типа - это применение методов intValue(), doubleValue() и т.д в классах-обертках. Раньше до JDK 5  приходилось использовать старый подход, но из-за этого снижалась читаемость кода. Но благодаря autoboxing, autounboxing конвертировать из примитива в класс-обертку и обратно уже не нужно. 







---
---
---

<h1>*** MULTITHREADING. MAIN QUESTIONS</h1>
---
<h2>* Multithreading. Потоки. Для чего нужны? </h2>

Чтобы создать поток есть 3 способа: <br>
* отнаследоваться от класса Thread (MyThread extends Thread);
* заимплементить интерфейс Runnable и вставить инстанс класса в конструктор Thread класса (MyThread implements Runnable);   
* создание потока через Анонимные классы. 

Ключевые слова: 
* <b>volatile</b> - это говорит потокам что это значение может изменяться другими потоками. Потоки как работают: обычно копируют переменные в кэш и работают с этими локальными переменными. Однако если переменная измениться, поток об этом может не узнать. Volatile-переменные предупреждает потоки, что они его не копировали и каждый раз когда к ней будут обращаться смотрели к главной копии этой переменной.  
* <b>synchronized</b> - когда мы синхронизируем метод, это означает что доступ к методу параллельно имеет достип только строго один поток. И если другой поток видит, что метод занят, то он переходит в режим ожидания до тех пор пока мютекс метода не освободится.<br>
Бывают синхронированные методы, синхронизованные блоки.  
Ключевые методы на потоках:
* <b>join</b> - ждем пока поток не остановится. 
* <b>wait</b> - останавливаем работу поток пока не поступит команда (может применяться только в блоке synchronized)
* <b>notify, notifyAll</b> - предупреждаем потоки что можно продолжить работу. Также применяется только в блоке synchronized. 
---
<h2>* Что такое ThreadPool. Для чего используется?</h2>
Thread pool - пул тредов.<br>
<b>Example</b>: ExecutorService executorService = Executors.newFixedThreadPool(2);<br>
То есть через newFixedThreadPool создается пул из 2 потоков. То есть параллельно могут выполняться 2 потока. 
Запуск потока происходит через команду executorService.submit(Runnable thread). Если в пуле уже 2 потока, то следующий поток будет ждать пока есть освободиться место для него в executorService. 

---
<h2>* Что такое семафора. Где используется? </h2>
Semaphore. Методы - Используется для контроля доступа к объекту. Используется как средство для доступа к ресурсу. 
Семафор используется как счетчик, представляющий количество разрешений. Если значение счетчика больше 0, значит 

Semaphore(int permits), где permits - кол-во разрешений. 


---
<h2>* Что такое Atomic Integer</h2>
Есть пакет java.concurrent.atomic. Этот пакет содержит большое кол-во полезных классов для выполнения атомарных операций. 
Atomic Integer - это атомарный класс.<br> 
Что такое атомарная операция? <br>
Операция называется атомарной тогда, когда ее можно безопасно выполнять при параллельных вычислениях в нескольких потоках, не используя при этом ни блокировок, ни synchronized. 
Атомные операции позволяют выполнять вычисления для нескольких потоков без использования блокировок, таким образом производительность системы не падает. При sycnhronized расчеты правильные, но очень сильно падает производительность системы, т.к. если метод занят одним потоком, то другим потокам придется подождать пока освободится необходимый метод.
То есть если необходимо изменить одну переменную с помощью нескольких потоков, то лучше использовать атомарные классы. 

Пример для Atomic Integer - один из атомарных классов.<br>
Бывают еще AtomicBoolean, AtomicLong и т.д.<br>

Пример счетчика с применением класса AtomicInteger:
<p>

    public class SafeCounterWithoutLock {

    private final AtomicInteger counter = new AtomicInteger(0);

    public int getValue() {
        return counter.get();
    }
    public void increment() {
        while(true) {
            int existingValue = getValue();
            int newValue = existingValue + 1;
            if(counter.compareAndSet(existingValue, newValue)) {
                return;
            }
        }
    }
    }
</p>

---
<h2>ThreadPool - Пул нитей. Что это? </h2>

Есть класс ThreadPoolExecutor - это класс, который имееть в себе 2 компоненты: <br>
* Очередь задач, в которую можно добавлять задачи.
* Пул-нитей - которые эти задачи испольняют. 

После исполнении задачи нити в пуле не уничтожаются, они переходят в спящий режим.
<br>Как работает ThreadPoolExecutor:
* При добавлении нового задания, оно помещается в конец очереди;
* Если очередь заполнена будет выкинуто исключение;
* Каждая нить послед выполнения задания берет из очереди следующее задание и выполняет его;
* Если задач в очереди нет, нить засыпает до их добавления. 

<b>ПРИМЕР</b>
<p>

    ExecutorService service = Executors.newFixedThreadPool(2);
    for(int i = 0; i < 10; i++)
    {
    service.submit(new Runnable() {
    public void run()
    {
    // тут мы загружаем что-то тяжелое из интернета.
    }
    });
    }

</p>

<h2>Интерфейс Callable</h2>
Интерфейс Callable больше подходит для параллельного выполнения небольших задач, чем Runnable and Thread. <br>
Этот интерфейс поддерживает пробрасывание исключений, а также позволяет узнавать результаты выполнения задач. 
<br>
В отличие от Runnable в этом интерфейсе нужно переопределить метод call. <br>
Пример:<br>

    class ReverseString implements Callable<String>
    {
    String str;
    
    ReverseString(String str)
    {
    this.str = str;
    }
    
    public String call() throws Exception
    {
    StringBuilder builder = new StringBuilder(str);
    builder.reverse();
    return builder.toString();
    }
    }

Интерфейс Callable можно применять для ThreadPools.<br>
Привожу пример:<br>
    
    //1. Создаем ThreadPoolExecutor
    ExecutorService service = Executors.newFixedThreadPool(5);
    
    //2 помещаем в него задачу для выполнения
    Future<String> task = service.submit(new ReverseString("Amigo"));
    
    //3 ждем пока задача выполнится
    while(!task.isDone())
    {
    Thread.sleep(1);
    }
    
    //4 пробуем получить результат задачи
    //получим или результат или исключение, если оно было при выполнении задачи
    try
    {
    System.out.println("Развернутая строка : " + task.get());
    }
    catch (Exception ie)
    {
    ie.printStackTrace(System.err);
    }
    
    //5 останавливаем ThreadPool.
    service.shutdown();

Метод submit возвращает объект поддерживающий интерфейс Future. У интерфейса Future есть следующие методы:
* cancel (Останавливает задачу.);
* isCancelled (Возвращает true, если задача была остановлена.);
* isDone (Возвращает true, если выполнение задачи завершено.);
* get (Возвращает результат вызова метода call или кидает исключение, если оно было.); 

---
---
---

<h1>JAVA EE (ENTERPRISE EDITION</h1>

---
<h2>Что такое Сервлет? Что такео сервер? Что такое Tomcat?</h2>
Сервлет - это программа, работающая на сервере, которая взаимодействует с клиентами посредством принципа запрос-ответ. 
Tomcat - это веб-сервер и контейнер сервлетов. То есть он принимает запросы от клиента, отправляет запрос на обработку в нужный сервлет и ответ отправляет обратно клиенту. 



---
---
---

<h1>*** SPRING, SPRING BOOT, SPRING CORE, SPRING MVC, SPRING JPA и т.д. </h1>
---
<h2>Что такое REST API</h2>
REST - Representational State Transfer. Отличительной особенностью сервисов REST является то, что они позволяют наилучшим образом использовать протокол HTTP. 
REST - это архитектура, принципы построения распределенных гипермедиа систем, того что другими словами называют World Wide Web. 
---
<h2>Spring Framework</h2>
Основные 3 компонента Spring Framework.
* Контекст приложения (Application Context) и Внедрение зависимостей (Dependency Injection);
* Удобрый и и эффективный доступ к БД (замена JDBC);
* Компонент для разработки Web - приложений (Spring MVC) - 
а также существуют множество других компонент (Spring Security, Spring Boot, Spring Webflow и т.д. )

Application Context - очень важная часть Spring Framework. 

Spring конфигурировать можно следующими способами. 
* Применение XML файла конфигураций (ApplicationContext.xml), но это уже старый способ; 
* Java аннотаций и немного XML; 
* Вся конфигурация на Java коде. 

Особенностью SpringBoot является удобная работа с зависимостями Dependency Injection.
Через xml файл или через аннотации или другими способами можно описать объекты и их зависимости между собой, что при большом объеме классов уменьшает кол-во написанного кода и упрощает жизнь программиста. 
 
Приведу способы внедрения зависимостей:
* Через конструктор;
* Через setter; 
* Можно внедрять ссылки или простые значения;
* Можем внедрять значения из внешнего файла;
* Через scope, init-method, destroy-method, factory method и т.д.
* Через XML, Java-аннотации или Java - код. 
* Через Autowiring.

Основные параметры bean-а:
1) id - id бина;
2) class - класс бина, указываются относительный путь бина;
3) scope - 
Bean scope позволяет указывать какую ссылку хотим применять к бину. 
Виды scope: Singleton, Prototype, request, session, global-session.
Singleton - используется когда у нашего бина нет изменяемых состояний. При каждом новом получении бина ссылка на объект один и тот же. 
Prototype - при создании каждого последующего бина создаются новые инстансы класса (то есть ссылки на бины отличаются). 
4) init-method - метод, который будет вызываться при инициализации бина;
5) destroy-method - метод, который будет вызываться при остановке бина;
Для init, destroy методов может быть любой модификатор доступа (public, protected, private)
Эти методы не должны принимать на вход какие-либо аргументы. 
Для бинов со скоупом Prototype нельзя вызвать destroy.
6) factory-method - если объекты класса создаются фабричным методом, то можно определить этот параметр. 

---
<h2>Аннотации в Spring Boot. Почему лучше чем конфигурирование через Xml</h2>
Преимущества:
* Короче;
* Удобнее;
* Код более читабельный. 

Виды аннотаций Spring-а:<br>
* <b>@Component</b> - помечаем если хотим чтобы Spring создал бин из этого класса
* <b>@Autowired</b> - его можно использовать для конструктора, для setter-а или для на поле (Спринг использует Reflection API). 
Через autowired происходит поиск подходящего объекта для инициализации текущего класса. <br>
Если Autowired применен к конструктору, то Spring поймет что внедрять зависимости нужно через конструктор, <br>
Если Autowired применен для метода (не важно как будет называться), то DI будет происходить через этот метод, <br>
Если Autowired применен для параметра, то Spring используя Reflection будет производить DI. <br>

Все 3 способа для Autowired (через конструктор, метод, параметр) можно использовать, Главное - это стараться не смешивать разные стили, лучше в проекте придерживаться одного выбранного. 

* <b>@Qualifier</b> - уточнитель, используется когда для аннотации Autowired необходимо уточнить какой бин следует использовать для создания текущего бина. 
Qualifier для конструктора немного по-другому записывается. Пример ниже:<br>

@Autowired<br>
public MusicPlayer(@Qualifier("rockMusic") Music music1, @Qualifier("classicalMusic") Music music2) {<br>
    this.music1 = music1;<br>
    this.music2 = music2;<br>
}

* <b>@Scope</b>
Можно указать как будет создаваться бин. "singleton" - один инстанс и в дальнейшем Spring будет всегда ссылаться на этот инстанс, "prototype" - с каждым новым созданием бина новый инстанс. 

* <b>@Value</b>
Указывает значение для параметра

* <b>@PostConstruct</b>
(Init метод - Spring вызывает метод перед созданием бина)

* <b>@PreDestroy</b>
(Destroy - Spring вызывает этот метод при уничтожении бина)

* <b>@Configuration</b>
Аннотация Configuration можно использовать вместо xml файла конфигурирования. 
То есть помечаем Java класс, который мы хотим использовать для конфигурирования Spring приложения. 
* <b>@ComponentScan</b>
Эта аннотация аналогична тэгу component-scan в xml файле. Эта аннотация необходима, чтобы указать директория всех Java классов для Аннотирования. 
* <b>@PropertySource</b>
Эта аннотация замена тэгу property-placeholder для получения данных из .properties файл
---
<h2>Spring MVC</h2>
Spring MVC состоит из следующих компонент:
* обычные классы (Java классы, модели и прочее); 
* набор HTML страниц. + JavaScript + CSS;
* Spring configuration (XML, Annotation, Java).













