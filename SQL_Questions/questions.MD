

---
<h2>* Что такое нормализация и денормализация данных? </h2>
Нормализация отношений в SQL призвана организовать информацию в базе данных таким образом, чтобы она не занимала много места и с ней было удобно работать. Это удаление избыточных данных, устранение дублей, идентификация наборов связанных данных через PRIMARY KEY, etc.

---
<h2>* Из каких подмножеств состоит SQL?</h2>
<p>1) DDL (Data Definition Language, язык описания данных) — позволяет выполнять различные операции с базой данных, такие как CREATE (создание), ALTER (изменение) и DROP (удаление объектов).</p>
<p>2) DML (Data Manipulation Language, язык управления данными) — позволяет получать доступ к данным и манипулировать ими, например, вставлять, обновлять, удалять и извлекать данные из базы данных.</p>
<p>3) DCL (Data Control Language, язык контролирования данных) — позволяет контролировать доступ к базе данных. Пример — GRANT (предоставить права), REVOKE (отозвать права).<p>

---
<h2>* Query ordering of execution</h2>
Очень важно знать последовательность Команд используемых в SQL запросах <br>

Последовательность:
* FROM and JOIN
* WHERE
* GROUP BY
* HAVING
* SELECT
* DISTINCT
* ORDER BY
* LIMIT / OFFSET

---
<h2>* 4 основных типы соединения в SQL<br></h2>
Соединение таблиц может быть внутренним (INNER) или внешним (OUTER), причём внешнее соединение может быть левым (LEFT), правым (RIGHT) или полным (FULL).

![](images/joins.jpg)

<b>* INNER JOIN</b> — получение записей с одинаковыми значениями в обеих таблицах, т.е. получение пересечения таблиц.<br>
<b>* FULL OUTER JOIN</b> — объединяет записи из обеих таблиц (если условие объединения равно true) и дополняет их всеми записями из обеих таблиц, которые не имеют совпадений. Для записей, которые не имеют совпадений из другой таблицы, недостающее поле будет иметь значение NULL.<br>
<b>* LEFT JOIN</b> — возвращает все записи, удовлетворяющие условию объединения, плюс все оставшиеся записи из внешней (левой) таблицы, которые не удовлетворяют условию объединения.<br>
<b>* RIGHT JOIN</b> — работает точно так же, как и левое объединение, только в качестве внешней таблицы будет использоваться правая.<br>

<b>* NATURAL JOIN</b> - соединение таблиц по столбцам с одинаковыми названиями. <br>
<b>* CROSS JOIN</b> - оператор перекресного соединения, или декартово произведение. 
Аналогичен команде:

      SELECT name_author, name_genre
      FROM author, genre;

---
<h2>* Self join</h2>
Объединение таблицы саму на себя. 
Например есть таблица с id работников + id менеджера. 
В случае есть мы хотим получить результат и чтобы там отображалось имя и фамилия менеджера работника необходимо объединить одну и ту же таблицу. 

Пример запроса:<br>

      DROP TABLE IF EXISTS employees; 

      CREATE TABLE employees (
            id integer primary key, 
            full_name varchar(50) not null, 
            title varchar(30) not null, 
            manager_id integer
      ); 

      INSERT INTO employees (id, full_name, title, manager_id) 
      VALUES 
      (1, 'Petrov', 'Programmer', 2), 
      (2, 'Denisov', 'Manager', null), 
      (3, 'Anishev', 'Lead Programmer', 2); 

      
      SELECT emp.id, emp.full_name emp_name, mng.full_name mng_name FROM employees emp LEFT JOIN employees mng ON emp.manager_id=mng.id;


--- 
<h2>* Cross join</h2>

Операция JOIN, производящая декартово произведение двух таблиц. При использовании оператора SQL CROSS JOIN каждая строка левой таблицы сцепляется с каждой строкой правой таблицы. В результате получается таблица со всеми возможными сочетаниями строк обеих таблиц.

Синтаксис:

      SELECT
          column_names [,... n]
      FROM
          Table_1 CROSS JOIN Table_2

---
<h2>Типы данных для полей.</h2>

* INTEGER (INT) - Целое число, могут принимать значения от -2 147 483 648 до 2 147 483 647 <br>
* DECIMAL (NUMERIC) - Вещественное число, <br>
* VARCHAR - строка длиной не более 255 символов. В скобках указывается максимальная длина строки. 
* DATE - Дата в формате YYYY-MM-DD. <br>
* DATETIME - Дата в формате YYYY-MM-DD HH:MM:SS <br>
* TIMESTAMP - TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC. <br>
* TIME - HH:MM:SS format; 

---
<h2>* Примеры как создавать Таблицу. CREATE Command. </h2>
* Через обычный CREATE: <br>

      CREATE TABLE example_table (
         example_id PRIMARY KEY AUTO_INCREMENT, 
         title VARCHAR(30), 
         amount INT, 
         price DECIMAL(8,2)
      ); 
<br>

* Через CREATE AS SELECT: <br>

      CREATE TABLE ordering AS
      SELECT author, title, 5 AS amount FROM book 
      WHERE amount < 4; 

---
<h2>* Обновление данных в таблицы. UPDATE Command.</h2>

Пример команды:<br>

        UPDATE book b
        SET b=amount=b.amount+1, b.price=b.price*1.1
        WHERE b.price<500; 

---
<h2>* Foreign Key. Действия при удалении записи главной таблицы</h2>

Внешний ключ или FOREIGN KEY также является атрибутом ограничения и обеспечивает связь двух таблиц. По сути, это поле или несколько полей, которые ссылаются на PRIMARY KEY в родительской таблице.<br>

Пример:<br>
   
      CREATE TABLE order (
      order_id INT NOT NULL,
      user_id INT,
      PRIMARY KEY (order_id),
      FOREIGN KEY (user_id) REFERENCES users(id)
      );

C помощью выражения <b>ON DELETE</b> можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. 
<br>

* CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
* SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
* SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца.
* RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

--- 
<h2>* Case в SQL</h2>

Case позволяет выполнять определенные действия в зависимости от входных данных. 

К примеру, в помощью 'Case' можно обрабатывать ошибки ввида 'zero divition error'. Приведем пример:

      SELECT c.first_name, c.last_name, sum(p.amount) sum, count(p.amount) count,
          (sum(p.amount) / 
          CASE WHEN count(p.amount) = 0 THEN 1
              ELSE count(p.amount)
          END) avg_payment

Или пример выполнения UPDATE с помощью CASE: 

      UPDATE customer
      SET active =
        CASE
          WHEN 90 <= (SELECT datediff(now(), max(rental_date))
                      FROM rental r
                      WHERE r.customer_id = customer.customer_id)
            THEN 0
          ELSE 1
        END
      WHERE active = 1;

---
<h2>* Для чего нужен оператор UNION? </h2>
Он используется для объединения полученных данных из двух или более запросов, которые должны иметь одинаковое количество столбцов с одинаковыми типами данных и расположенных в том же порядке.

Пример использования:

<i> SELECT column(s) FROM first_table
UNION
SELECT column(s) FROM second_table;</i>

<h5> Разница между UNION и UNION ALL</h5>
UNION удаляет повторяющиеся записи (где все столбцы в результатах одинаковы), UNION ALL - не удаляет.
При использовании UNION вместо UNION ALL наблюдается снижение производительности , поскольку сервер баз данных должен выполнять дополнительную работу по удалению дубликатов строк, но обычно дубликаты не нужны (особенно при разработке отчетов).<br>
* UNION выполняет функцию DISTINCT в результирующем наборе, устраняя все повторяющиеся строки.<br>
* Объединение всех не удаляет дубликатов, а это поэтому быстрее чем UNION.

---
<h2>* Операция Intersect. Отличие от Union</h2>
Операция Intersect возвращает уникальные строки, выводимые левым и правым входными запросами. 
<br>
Основные правила объединения результирующих наборов двух запросов таковы:
* Количество и порядок столбцов должны быть одинаковыми во всех запросах;
* Типы данных должны быть совместимыми. 
<br><br>
Intersect, как и Union объединяет 2 таблицы (Query1 и Query2). 
Только отличие в том, что если Query1 возвращает колонки A,B и Query2 возвращает колонки B,C, то UNION соединяет все колонки и вовращает A,B,C. INTERSECT возвращает только колонку B. 
  
---
<h2>* Операция EXCEPT</h2>
Оператор EXCEPT возвращает уникальные строки из левого входного запроса, которые не выводятся правым входным запросом.

---
<h2>* Объясните разницу между командами DELETE и TRUNCATE ?</h2>
Команда DELETE — это DML-операция, которая удаляет записи из таблицы, соответствующие заданному условию:<br>


<table>
<caption>Таблица Delete vs Truncate</caption>
    <tr>
    <th>DELETE</th>
    <th>TRUNCATE</th>
    </tr>
    <tr><td>Используется для удаления строки в таблице</td><td>Используется для удаления всех строк из таблицы</td></tr>
    <tr><td>Вы можете восстановить данные после удаления</td><td>Вы не можете восстановить данные (прим. перевод.: операции логируются по разному, но в SQL Server есть возможность сделать откат) транзакции)</td></tr>
    <tr><td>DML-команда</td><td>DDL-команда</td></tr>
    <tr><td>Медленнее, чем оператор TRUNCATE</td><td>Быстрее</td></tr>
</table>


<i>DELETE FROM table_name WHERE condition;</i>
При этом создаются логи удаления, то есть операцию можно отменить.

А вот команда TRUNCATE — это DDL-операция, которая полностью пересоздаёт таблицу, и отменить такое удаление невозможно:

<i>TRUNCATE TABLE table_name;</i>

---
<h2>* Как найти дубли в поле email? </h2>

<i>SELECT email, COUNT(email)<br>
FROM customers<br>
GROUP BY email<br>
HAVING COUNT(email) > 1;<br></i>

Функция COUNT() возвращает количество строк из поля email. Оператор HAVING работает почти так же, как и WHERE, вот только применяется не для всех столбцов, а для набора, созданного оператором GROUP BY.

---
<h2>* Замените в таблице зарплату работника на 1000, если она равна 900, и на 1500 в остальных случаях</h2>

Замена значений — одна из наиболее часто встречаемых задач по SQL на собеседованиях. Решить её несложно:

<i>
UPDATE table SET salary = <br>
CASE<br>
WHEN salary = 900 THEN 1000<br>
ELSE 1500<br>
END;<br>
</i>

Оператор UPDATE используется для изменения существующих записей. Но ответы на подобные вопросы с собеседований по SQL должны быть более развёрнутыми. Уточните,что после UPDATE следует указать, какие записи должны быть обновлены. В противном случае обновятся все записи в таблице.

В нашем примере условие задаётся через оператор CASE: если текущая зарплата равна 900, изменяем её на 1000, в остальных случаях — на 1500.

---
<h2>* Переименуйте таблицу</h2>
<i>ALTER TABLE first_table RENAME second_table;</i>

С помощью оператора ALTER TABLE можно добавлять, удалять, изменять столбцы, а также изменять название таблицы.

---
<h2>* DCL - Data Control Language</h2>
Команды:<br>
* GRANT (дать разрешение); <br>
* REVOKE (отзывать разрешение); <br>
* DENY; (задаем запрет, имеет приоритет над GRANT)<br>

<br>
* Grant - предоставляет пользователю или группе разрешения на определенные операции с объектом. 
Пример команды:<br>

      GRANT SELECT, INSERT, UPDATE, DELETE ON Goods TO TestUser; 

Пример как дать разрешение на запуск процедуры. 

      GRANT EXECUTE ON TestProcedure TO TestUser; 
<br>
* Revoke - отзывает выданные разрешения.<br>
Примеры:

      --Отменяем разрешение на удаление данных
      REVOKE DELETE ON Goods To TestUser; 
      

      --Отменяем разрешение на запуск процедуры
      REVOKE EXECUTE ON TestProcedure TO TestUser;

<br>
* DENY - задает запрет, имеющий приоритет над разрешением. 
<br>

С помощью DENY мы явно запрещаем выполнение определенных действий даже в том случае, если пользователь состоит в группе или роли, которая имеет разрешение на выполнение этих действий. Таким образом, мы предотвращаем наследование разрешения участником через его членство в группе или роли.
DENY имеет приоритет над всеми разрешениями, но не применяется к владельцам объектов или членам с предопределенной ролью сервера sysadmin, так как им не может быть отказано в разрешениях.

Пример:
DENY EXECUTE ON TestProcedure To TestUser; 

---
<h2>* Транзакции. Виды команд и что значат</h2>
Это последовательность операций, выполняемых в логическом порядке пользователем, либо программой, которая работает с БД. 
Основные концепции транзакции описываются аббревиатурой ACID. 

Для управления транзакциями существуют следующие команды:<br>
* COMMIT (Сохранение изменений) <br>
* ROLLBACK (Отмена изменений) <br>
* SAVEPOINT (создание точки к которой группа транзакций может откатиться) <br>
* SET TRANSACTION (размещение имени транзакции) <br>

---
<h2>* В чем разница между типом данных CHAR и VARCHAR в SQL?</h2>

И Char, и Varchar служат символьными типами данных, но varchar используется для строк символов переменной длины, тогда как Char используется для строк фиксированной длины. Например, char(10) может хранить только 10 символов и не сможет хранить строку любой другой длины, тогда как varchar(10) может хранить строку любой длины до 10, т.е. например 6, 8 или 2.

---
<h2>* Аналитические функции</h2>

### Скользящее окно <br>

      select quarter(payment_date) quarter,
          monthname(payment_date) month_nm,
          sum(amount) monthly_sales,
          max(sum(amount)) over () max_overall_sales,
          round(max(sum(amount)) over (partition by quarter(payment_date)),1) max_qrtr_sales,
          round(avg(sum(amount)) over (partition by quarter(payment_date)),1) avg_qrtr_sales
      from payment 
      where year(payment_date) = 2005
      group by quarter(payment_date), monthname(payment_date)

### Ранжирование <br>

Виды ранжирование:
* row_number - возвращает уникальный номер для каждой строки.
* rank - возвращает тот же рейтинг в случае пересечений, с пробелами в рейтинге.
* dense_rank - возвращает тот же рейтинг в случае пересечений, без пробелов в рейтинге. 

Пример ранжирования:

      select customer_id, count(*) rental_amount,
          row_number() over (order by count(*) desc) row_number_rnk,
          rank() over (order by count(*) desc) rank_rnk,
          dense_rank() over (order by count(*) desc) dense_rank_rnk
      from rental
      group by customer_id
      order by rental_amount desc
      limit 10;

### "Lag" и "Lead"

* Lag - извлекает значение столбца из предыдущей строки
* Lead - извлекает значение столбца из следующей строки

Пример:

      select payment_date, yearweek(payment_date) payment_week, sum(amount) amount_sum_week,
      lag(sum(amount), 1) over () amount_lag, 
      lead(sum(amount), 1) over () amount_lead,
      round((sum(amount) - lag(sum(amount), 1) over ()) / sum(amount) * 100, 2) amount_lag_diff
      from payment 
      group by yearweek(payment_date)
      limit 10;

### "group_concat" - Конкатенация сгруппированных данных 

Пример:

      select f.title, count(*) film_actors_amt,
          group_concat(CONCAT(a.last_name, ' ', a.first_name) order by a.last_name separator ', ') actors
      from actor a
      inner join film_actor fa ON a.actor_id = fa.actor_id
      inner join film f ON fa.film_id = f.film_id
      group by f.title
      having count(*) < 3; 

---
<h2>* NoSQL базы данных</h2>
Преимущества NOSQL баз данных:<br>
* Гибкость (NoSQl предлагают гибкие схемы, что позволяет осуществлять разработку быстрее и обеспечивать возможность поэтапной реализации).
* Масштабируемость (Рассчитаны на масштабирование с использование распределенных кластеров аппаратного обеспечения)
* Высокая производительность
* Широкие функциональные возможности (Предоставляют API и типы данных с широкой функциональность)
<br>
  
Типы баз данных NOSQL:
* БД на основе пар "ключ-значение". Пример: Amazon DynamoDB; 
* Документ в формате, подобной на JSON. Пример: MongoDB; 
* Графовые БД. Они упрощают разработку и запуск приложений, работающих с наборами сложносвязанных данных. Типичные примеры использования - соц. сети, сервисы рекомендаций, системы выявления мошенничества и графы знаний. Пример: Amazon Neptune. 
* БД в памяти. Примеры: Amazon ElastiCache.
* Поисковые БД. Примеры: Amazon Elasticsearch. 

---
<h2>* Индексы в SQL. Зачем и где используются?</h2>

Ссылки:<br>
<a href="https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)">1) Вики</a><br>
<a href="https://postgrespro.ru/docs/postgresql/10/indexes-intro">2) Ссылка 2</a><br>
<a href="http://postgresguide.com/performance/indexes.html">3) Ссылка 3</a><br>
<a href="https://postgrespro.ru/docs/postgresql/9.6/indexes.html">4) Postgres docs</a><br>
<a href="https://tproger.ru/articles/indeksy-v-postgresql/">5) Индексы в PostgreSQL</a>


* Индексы позволяют достигать большой скорости производительности SQL запросов. Однако при неправильном использовании возможен и противоположный эффект.<br>
* Индекс ускоряет процесс запроса, предоставляя быстрый доступ к строкам данных в таблице, аналогично тому, как указатель в книге помогает вам быстро найти необходимую информацию. 
<br>
* Индекс состоит из набора страниц, узлов индекса, которые организованы в виде древовидной структуры - сбалансированного дерева. 
<br>

Однако следует понимать, что ускоряя доступ к данным с помощью индексов, взамен требуются определенные затраты на их поддержание. 


<b>Преимущества индексов:</b> 
* Индексы сокращают время поиска в абсолютном выражении. 
* Индексы уменьшают алгоритмическую сложность процесса поиска. 

<b>Недостатки индексов:</b>
* На поддержку индексов требуется память, поэтому нежелательно создавать большое кол-во индексов
* При обновлении, вставке данных в таблицу индексы должны пересчитываться для балансировки дерева. Если у нас будет много индексов, этот процесс очень продолжительным и болезненным. 

# Unique constraint vs unique index <br>

<a href="https://dba.stackexchange.com/questions/144/when-should-i-use-a-unique-constraint-instead-of-a-unique-index">Link</a><br>

По умолчанию в PostgreSQL используется индекс на основе B-дерева, однако если нужно создать индекс другого типа, это можно указать с помощью команды USING. Пример создания индекса в PostgreSql:<br>
      CREATE INDEX index_name ON table_name USING GIST (column_name)

<b>Общие Типы индексов</b>:
* Уникальный индекс (Unique index)
* Составной индекс (состоящий из нескольких колонок).
* Функциональный индекс (индекс по выражению) - индексация по результатам вычислений <br> 
позволяет быстро находить данные в таблице по результатам вычислений.<br>
SELECT * FROM table_name WHERE lower(text_field) = 'some_string_in_lower_case'<br>
CREATE INDEX index_name ON table_name(lower(text_field))

ПРИМЕР создания индекса:<br>
    CREATE INDEX idx_salary ON employees(salary);

или составной индекс:
    CREATE INDEX idx_salary ON employees(last_name, salary);

<b>Методы индексов</b>:
* <b>B-tree</b> - этот тип индекса используется по умолчанию и покрывает очень широкий круг задач (базы данных большинства приложений успешно могут обходиться только индексами на основе B-деревьев). Помимо ускорения запроса B-tree также ускоряет сортировку результатов, если в ORDER BY указано проиндексированное поле. Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен (зато способен очень хорошо!). 

* <b>GiST</b> - generalized search tree. Это сбалансированное дерево поиска, точно так же, как и рассмотренный ранее b-tree. Но b-tree применимо только к тем типам данных, для которых имеет смысл операция сравнения и есть возможность упорядочивания. Но PostgreSQL позволяет хранить и такие данные, для которых операция упорядочивания не имеет смысла, например, геоданные, геометрические объекты, текстовые документы, картинки. Он позволяет распределить данные любого типа по сбалансированному дереву и использовать это дерево для поиска по самым разным условиям. Если при построении B-дерева мы сортируем все множество объектов и делим его на части по принципу больше-меньше, при построении GiST индексов можно реализовать любой принцип разбиения любого множества объектов.

Gist может быть полезен при разработке геоинформационных систем, в которых возникают запросы вида "получить множество объектов на карте, находящихся от заданной точки на расстоянии не более 1 км". 

* <b>SP-GiST</b> - space partitioning generalized search tree. Он позволяет создавать несбалансированные деревья. Такие деревья могут быть полезны при разбиении множества на непересекающиеся объекты. К такому типу индексов можно отнести kd-деревья, реализация которых присутствует в PostgreSQL. 

SP-GiST состоит в разбиении области значений на неперекрывающиеся подобласти, каждая из которых, в свою очередь, также может быть разбита. Такое разбиение порождает несбалансированные деревья (в отличие от B-деревьев и обычного GiST).


* <b>GIN</b> - GIN индексы полезны для организации полнотекстового поиска и для индексации таких типов данных, как массивы или jsonb. 

---
<h2>* Constaint в SQL</h2>

Constraint - ограничители, это простое ограничение, накладываемое на один или несколько столбцов таблицы.

Виды Constaint: 
* <b>Primary key constraints</b> - гарантирует уникальность внутри таблицы <br>
* <b>Foreign key constraints</b> - ограничивает один или несколько столбцов, чтобы они содержали только значения, найденные в столбцах первичного ключа другой таблицы <br>
* <b>Unique constraints</b> - обязывает один или несколько столбцов, что они содержали уникальные значения в таблице <br>
* <b>Check constraints</b> - накладывает ограничение на столбец, чтобы он принимал только определенные значения <br>

---
<h2>* Использование в запросе нескольких источников записей</h2>
<a href="http://www.sql-tutorial.ru/ru/book_using_multiple_tables_in_query.html">Ссылка</a>

---
<h2>* ACID в базе данных?</h2>

* https://en.wikipedia.org/wiki/ACID

<b>ACID - атомарность Atomicity, согласованность (Consistency), изолированность (Isolation), долговечность (Durability).</b><br>

<b>Атомарность</b> - Транзакции состоят из множества последовательности запросов. Атомарность же гарантирует, что транзакция представляет из себя единый запрос/unit. 
То есть транзакция будет либо полностью выполнена или потерпит неудачу.
Это означает, что при сбое одной части любой транзакции, состояние базы данных остается неизменным.
<br>

<b>Согласованность</b> - Гарантирует, что данные должны соответствовать всем правилам валидации. 
Проще говоря, вы можете сказать, что ваша транзакция никогда не оставит вашу базу данных в недопустимом состоянии.<br>
Согласованность гарантирует что база данных будет переходит из одного валидного состояния в другое. 

<b>Изолированность</b> - Основной целью изолированности является контроль механизма параллельного изменения данных. 
Как известно транзакции могут происходить в несколько параллельных потоков (то есть множественное чтение и запись данных). 
Изоляция гарантирует, что параллельная обработка транзакций будет аналогична их последовательной обработке.  
<br>

<b>Долговечность</b> - Долговечность подразумевает, что если транзакция была подтверждена (COMMIT), произошедшие в рамках транзакции изменения сохранятся независимо от того, что может встать у них на пути (например, потеря питания, сбой или ошибки любого рода).
То есть завершенные транзакции никуда не пропадают (даже при отключении электричества), они сохраняются в долговременную память (non-volatile memory). 


# View, Stored View, Stored Procedure (Хранимая процедура). Отличия, примеры, когда использовать

---
<h2>* Виды в SQL. Views.</h2>

* https://www.postgresqltutorial.com/postgresql-views/
* https://www.postgresqltutorial.com/managing-postgresql-views/

#### Вид(View) <br>

это SQL запрос, который хранится в базе данных с определенным именем. Это таблица, которая хранится в форме предопределенного SQL запроса. Его можно изменять, удалять, вызывать. Следует обратить внимание, что обычные View не хранят никаких данных, кроме материализованных View.

Преимущества View:
* Data Security - позволяет скрывать исходные таблицы и предоставлять данные через View. 
* Hiding Complexity - сокрытие сложности запроса, что позволяет сконцентрироваться на бизнес задачах.
* Joining Partitioned Data - когда данных в таблице много, часто делят большую таблицу на партиции (partitions). При появлении партиции запрос к данным изменяется. Если же использовать View, то достаточно один раз его обновить и обращаться к данным. 

Для создания Вида используется команда CREATE VIEW. 
      
      CREATE VIEW имя_вида AS
      SELECT колонка1, колонка2.....
      FROM имя_таблицы
      WHERE [условие];

Чтобы вызвать Вид нужно выполнить следующую команду:

      SELECT * FROM ViewName;

Чтобы изменить название View нужно выполнить следующую команду:

      ALTER VIEW customer_master RENAME TO customer_info;

Пример удаления View:

      DROP VIEW [ IF EXISTS ] view_name;

#### Materialized Views (Материализованный вид)<br>

Это физический объект данных, содержащий результат выполнения запроса. В материализованном представлении уже заранее хранятся вычисленные результаты запроса. 
Поэтому запрос выполняется намного быстрее. 
<br>
Однако недостатком является то, что данные, которые вы получаете от материализованного view, являются только такими же актуальными, как и в последний раз, когда материализованный view был обновлен. 
Материализованные представления чаще всего используются в приложениях хранилища данных/бизнес-аналитики, где запрос больших таблиц фактов с тысячами миллионов строк приведет к увеличению времени ответа на запрос, что приведет к непригодности приложения. 


Синтаксис создания материализованного View:

      CREATE MATERIALIZED VIEW view_name
      AS
      query
      WITH [NO] DATA;


Пример обновления материализованного View.

      REFRESH MATERIALIZED VIEW view_name;

В момент обновление материализованного View, БД блокируют всю таблицу, поэтому в этот момент нельзя делать запросы к этой таблице. Чтобы избежать это, можно использовать опцию <b>CONCURRENTLY</b>.

      REFRESH MATERIALIZED VIEW CONCURRENTLY view_name;

Удаление материализованного View:

      DROP MATERIALIZED VIEW view_name;

---
<h2>* Хранимые процедуры (Stored procedures / User-defined Procedures)</h2>

* https://www.w3schools.com/sql/sql_stored_procedures.asp
* https://www.postgresql.org/docs/11/xproc.html
* https://www.postgresql.org/docs/11/sql-createprocedure.html
* https://postgrespro.ru/media/docs/postgresql/11/ru/postgres-A4.pdf - учебник, документация

Храни́мая процеду́ра — объект базы данных, представляющий собой набор SQL-инструкций, который компилируется один раз и хранится на сервере. Хранимые процедуры похожи на определяемые пользователем функции (UDF). Основное различие заключается в том, что пользовательские функции можно использовать как и любое другое выражение в SQL запросе, в то время как хранимые процедуры должны быть вызваны с помощью функции CALL:

Основные отличия от функции:
* создание процедур происход по команде CREATE PROCEDURE
* Процедуры не возвращают ничего, то есть в команде CREATE PROCEDURE отсутствиет опция RETURNS
* Процедура вызывается с помощью команды CALL
* Процедура, в отличие от функции, может фиксировать или откатывать транзакции во время ее выполнения (а затем автоматически начинать новую транзакцию), если вызывающая команда CALL находится не в явном блоке транзакции. 

Синтаксис:

      CREATE [ OR REPLACE ] PROCEDURE
      name ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )
      { LANGUAGE lang_name
      | TRANSFORM { FOR TYPE type_name } [, ... ]
      | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
      | SET configuration_parameter { TO value | = value | FROM CURRENT }
      | AS 'definition'
      | AS 'obj_file', 'link_symbol'
      } ...

Синтаксис выхода хранимой процедуры:

      CALL процедура(…)

или

      EXECUTE процедура(…)


<h2>* Функции (Function)</h2>

* https://postgrespro.ru/media/docs/postgresql/11/ru/postgres-A4.pdf - учебник, документация

Пример:

      CREATE FUNCTION add(integer, integer) RETURNS integer
      AS 'select $1 + $2;'
      LANGUAGE SQL
      IMMUTABLE
      RETURNS NULL ON NULL INPUT; 

---
<h2>* Оконные функции</h2>
Это функции, которые позволяют осуществлять вычисления в заданном диапазоне строк внутри предложения Select.

Синтаксис:

Оконная функция (столбец для вычислений) OVER ([PARTITION BY столбец для группировки] [ORDER BY столбец для сортировки] [ROWS или RANGE выражение для ограничения строк в пределах группы])
sum(amount) - пример оконной функции, partition by id (оконная функции по id). 

---
<h2>Вложенный запрос, операторы ANY, ALL</h2>
Операторы ANY и ALL используются в SQL для сравнения некоторого значения с результирующим набором вложенного запроса. 

При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY():

Примеры:<br>
* amount > ANY(10,12) эквивалентно amount>10;<br>
* amount < ANY(10,12) эквивалентно amount<12; 

При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:
* amount > ALL (10, 12) эквивалентно amount > 12 <br>
* amount < ALL (10, 12) эквивалентно amount < 10

<b>Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. </b>

---
<h2>* Интересные встроенные функции для Дат.</h2>
* DATEDIFF(дата_1, дата_2) - кол-во дней между дата_1 и дата_2;
* MONTH(дата) - получить месяц даты. 
* DAY(дата) - получить день даты. 
* YEAR(дата) - получить год даты. 
* MONTHNAME(дата) - получить название месяца на английском языке. 

---
<h2>* Оптимизация запросов. </h2>

<a href="https://habr.com/ru/post/203320/">1) Ссылка 1</a><br>
<a href="https://habr.com/ru/post/203386/">2) Ссылка 2</a><br>
<a href="https://habr.com/ru/post/203484/">3) Ссылка 3</a><br>

---
<h2>* SEQUENCE В SQL </h2>
SEQUENCE - это объект последовательность, которая генерирует числовые значения в определенной последовательности в соответствии с заданной спецификацией. 

Синтаксис SEQUENCE
        
        CREATE SEQUENCE [schema_name].[sequence_name]
        [ AS [data type] ]
        [ START WITH < value > ]
        [ INCREMENT BY < value > ]
        [ MINVALUE [ < value > ] | NO MINVALUE ]
        [ MAXVALUE [ < value > ] | NO MAXVALUE ]
        [ CYCLE | NO CYCLE ]
        [ CACHE [ < value >] | NO CACHE ];

Примеры создания Sequence: <br>

* Создание Sequence c начальным значением 10 и увеличением на 5ж 

        CREATE SEQUENCE TestSequence
        START WITH 10
        INCREMENT BY 5;

* Создание SEQUENCE с заданным типом данных

        CREATE SEQUENCE TestSequence
        AS TINYINT
        START WITH 1
        INCREMENT BY 1;

Псевдостолбы NEXTVAL и CURRVAL: <br>
* NEXTVAL возвращает следующее доступное значение последовательности. Оно возвращает уникальное значение каждый раз, когда на него ссылаются, даже для различных пользователей.
* CURRVAL получает текущее значение последовательности.

---
<h2>* Что такое SQL Injection. Особенности, как поботься. </h2>

# TODO
