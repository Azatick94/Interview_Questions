<h0><b>НАВИГАЦИЯ</b></h0><br><br>

* [COMMON QUESTIONS](#core_java)
* [CORE JAVA](#core_java)
* [JAVA COLLECTIONS](#java_collections)
* [STREAM API](#stream_api)
* [GENERICS](#generics)
* [MULTITHREADING](#multithreading)
* [REFLECTIONS](#reflections)
* [JAVA ENTERPRICE EDITION](#java_ee)
* [SPRING, SPRING BOOT](#spring)
* [TESTING](#testing)
* [DESIGN PATTERNS](#design_patterns)

---

# <a name="common_questions"></a>

<h1>*** Common Questions</h1>

---
<h2>* Что такое WebService?</h2>

* https://semantica.in/blog/chto-takoe-veb-servis.html

Веб-сервисы (или веб-службы) — это технология. Это программа, которая организовывает взаимодействие между сайтами.
Информация с одного портала передается на другой.<br>
Например, есть авиакомпания. У нее много рейсов, соответственно, много билетов. Информацию через веб-службу она передает
сайту-агрегатору тур-путешествий. Пользователь, который заходит на агрегатор, сможет прямо там купить билеты этой
авиакомпании.<br>
Другой пример веб-сервисов — это сайт отслеживания погоды, который содержит сведения о метеоусловиях в конкретном городе
или по стране в целом. Данная информация также часто используется сторонними приложениями.<br>

Можно определить 3 инстанции, которые взаимодействуют между собой: каталог, исполнитель и заказчик. После создания
сервиса, исполнитель регистрирует его в каталоге, а там сервис находит заказчик.

Механизм обмена данными формируется в описании Web Services Description. Это спецификация, охватывающая форматы
пересылки, типы контента, транспортные протоколы, которые применяются в процессе обмена сведениями между заказчиком и
транспортировщиком услуг. Сегодня чаще всего используются несколько технологий для реализации различных веб-сервисов:

<br>* TCP/IP – протокол, который понимается практически любым сетевым оборудованием, от мэйнфреймов до портативных
устройств и PDA.
<br>* HTML - универсальный язык разметки, используемый для демонстрации контента устройствами потребителей.
<br>* XML – универсальное средство для обработки всех разновидностей данных. На его базе могут работать и прочие
протоколы обмена информацией: SOAP и WSDL.
<br>* UDDI – универсальный источник распознавания, интеграции и описания. Работает, как правило, в частных сетях и пока
не нашел достаточного распространения.

---
<h2>* Что такое Docker?</h2>
Полезные ресурсы:<br>

* https://docs.docker.com/get-docker/
* https://www.youtube.com/watch?v=FlSup_eelYE
* https://www.youtube.com/watch?v=3c-iBn73dDE&t=4364s

container - running environment of an image.

<b>Команды:</b>

### Создание Docker Image

* docker build -t test-app . - создание Docker-Image используя команды из DockerFile
* docker build -f Dockerfile -t test-app . - создание Docker-Image с указанием названия Dockerfile

### Основные команды для запуска/остановки контейнеров

* docker pull redis - скачать redis image из публичного репозитория Docker-Hub.

* docker run redis (docker pull+start) - запуск redis-контейнера
* docker run -d redis - запуск redis-контейнера в detached режиме
* docker run -p6000:6379 redis - запуск redis-контейнера в указанием портов, 6000-порт нашей машины, 6379-порт
  контейнера, то есть порт 6000 нашего хоста будет слушать порт 6370 redis-контейнера.
* docker run --name my_container redis - запуск redis-контейнера с именем "my_container"

* docker images - показать список всех images
* docker ps - показать список работающих контейнеров
* docker ps -a - показать список работающих/остановленных контейнеров

* docker stop ff7b935a34ad - остановить работу койтейнера с id = ff7b935a34ad
* docker start ff7b935a34ad - запустить койтейнер с id = ff7b935a34ad

### troubleshooting

* docker logs ff7b935a34ad - показать историю логов контейнера с id = ff7b935a34ad
* docker logs frosty_moser - показать историю логов контейнера с name = frosty_moser
* docker logs -f ff7b935a34ad - показать логи контейнера с id = ff7b935a34ad и постоянно добавлять логи в конец

* docker exec -it ff7b935a34ad - зайти внутрь контейнера и посмотреть что там есть


### additional options
* '--rm' - эта опция заставляет Docker автоматически после остановки убирать Контейнер
* '-it' - интерактивный мод, то есть при запуске заходим в Контейнер


---
<h2>* Java Messaging. RabbitMQ?</h2>

* https://www.rabbitmq.com/download.html (инструкция по установке)
* https://www.youtube.com/watch?v=o4qCdBR4gUM (пример Spring-boot приложения с использованием RabbitMQ)
* https://github.com/Azatick94/springboot-rabbitmq-example (пример простого Spring-Boot приложения с использованием
  RabbitMQ брокера сообщений)
* https://docs.spring.io/spring-amqp/docs/current/reference/html/ (Spring документация по протоколу AMQP)
* https://github.com/Azatick94/Rabbit_Tutorial (тут ссылка на пример приложения с несколькими Queue, Entity и Bindings между ними)  



Существуют 3 основных протоколов общения:
* STOMP (Simple Text-Oriented Messaging Protocol)
* MQTT (Message Queue Telemetry Transport) - publish-subscribe messaging
* AMQP (Advanced Message Queuing Protocol)

RabbitMq - это брокер сообщений, который имплементирует AMQP (Advance Message Queuing Protocol).

<br>
AMQP - Advanced Message Queuing Protocol - это открытый протокол для передачи сообщений между компонентами системы. RabbitMQ использует AMQP протокол для обмена сообщениями. <br>
RabbitMQ один из самых популярных имплементаций AMQP протокола. 


Архитектура RabbitMQ брокера
----------------------------
![alt text](https://images2.russianblogs.com/493/e0/e053077508746bd323781f53ac20248d.png)
<br>

<b>Основные термины:</b>
* <b>Producer</b>: Отправитель сообщений
* <b>Exchange</b>: маршрутизатор, получать сообщения и распространять сообщения на основе RoutingKey
* <b>Binding (RoutingKey)</b>: правила маршрутизации
* <b>Queue</b>: непосредственно сама очередь
* <b>Topics</b>: можно сказать составная часть письма-message, в котором в том числе хранится инфа по RoutingKey
* <b>Consumer</b>: Потребитель сообщений



<b>Основные виды Exchange: <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">Ссылка на статью</a></b>
* Direct Exchange (Прямой Обмен - подходит для одноадресного пересылания сообщений, через Exchange сообщение пересылается конкретному Queue используя конкретный RoutingKey)
* Fanout Exchange (В этом обмене использование RoutingKey игнорируется, все подписанные Queue получают сообщение от Exchange )
* Topic Exchange (Используется в многоадресной передаче сообщений)
* Headers Exchange (Для отправки сообщений вместо RoutingKey используется Headers с необходимой информацией)

<b>Основные параметры Queue:</b>
* Name - наименование очереди
* Durable - долговременные очереди или нет (boolean)
* Excludive - удалить очередь если больше не используется
* Auto-Delete - удалить очередь если подписчик отпишется 


<b>Ответ на вопрос как создать несколько потоков в SpringBoot:</b>
* https://stackoverflow.com/questions/41210688/multiple-rabbitmq-queues-with-spring-boot

<b>Динамическое создание Потоков (Queue):</b>
* https://stackoverflow.com/questions/57870894/how-to-create-dynamic-queues-in-rabbit-mq-using-spring-boot

# <a name="core_java"></a>

<h1>*** Core JAVA</h1>
---
<h2>* Парадигмы программирования</h2>
<p>* Объектно-ориентированное программирование. Наиболее распространённая на данный момент парадигма. Это подвид императивного программирования — оно основано на последовательных вызовах команд, изменяющих данные, с которыми работает программа. Таким образом она оперирует объектами, и это удобно для многих приложений.</p>
<p>* Функциональное программирование. По распространённости функциональная парадигма программирования занимает второе место после ООП. В ФП код программы состоит из функций, для которых подробно прописано, что должно быть на входе, а что — на выходе. Причём одну функцию вполне можно подать на вход другой в качестве аргумента. Так программа выполняется, запуская нужные функции. Преимущества функционального подхода — в том, что код легко читать, а тестирование упрощается.</p>
<p>* Cуществуют и другие парадигмы, но они менее распространены. Например - Императивное программирование (программирование инструкциями). То есть это машинные коды, языки ассемблера и ранние высокоуровневые языки, вроде Fortran. </p>
<p>* Структурное программирование - это уже объединение часто используемого императивного кода в шаблоны. </p>

---
<h2>* Алгоритмы и структура данных.</h2>

Виды сложностей и как ее рассчитывать:

* Time Complexity (Сколько требуется времени на выполнение алгоритма);
* Space Complexity (Сколько требуется памяти для выполнении алгоритма);

<b>Сложность по времени (Time Complexity)</b> выражается аннотацией Большая O (Big O notation). Big O выражает время
исполнения алгоритма с точки зрения как изменяется время с изменением входного массива (входной массив обозначается
как <b>n</b>).
<br>Подвиды сложности по времени:

* <b>O(1) (Константный)</b> - вычислительная сложность не зависит от входных данных.
* <b>O(n)</b> - Порядок роста O(n) означает, что сложность алгоритма линейно растет с увеличением входного массива.
* <b>O(log n) - (Логарифмический)</b> Порядок роста O(log n) означает, что время выполнения алгоритма растет
  логарифмически с увеличением размера входного массива. (Прим. пер.: в анализе алгоритмов по умолчанию используется
  логарифм по основанию 2). Большинство алгоритмов, работающих по принципу «деления пополам», имеют логарифмическую
  сложность.
  <br>
  К этой сложности относятся как правило алгоритмы типа "Разделяй и властвуй" ("Divide and Conquer").

* <b>O(n*log n) - (Линеарифметический)</b>. Примеры: сортировка слиянием и быстрая сортировка.
* <b>O(n2) - (Квадратичный)</b>. Время работы алгоритма с порядком роста O(n 2) зависит от квадрата размера входного
  массива. Несмотря на то, что такой ситуации иногда не избежать, квадратичная сложность — повод пересмотреть
  используемые алгоритмы или структуры данных. Проблема в том, что они плохо масштабируются. Например, если массив из
  тысячи элементов потребует. Пример: Пузырьковая сортировка.
* <b>O(2<sup>n</sup>) - (Экспоненциальная сложность)</b>. Как правило используется в ситуациях когда не известно
  наилучшее решение и приходится перебирать различные способы. <br>
  Пример этой сложности: Перебор методом <b>Brute-Force</b>.

---
<h2>* Алгоритмы типа "Разделяй и властвуй" (Divide and Conquer). Особенности. </h2>
Последовательность работы алгоритмов типа Divide and Conquer:

* Divide - разделение проблемы на подпроблемы такого же типа. <br>
* Рекурсивное решение подпроблем. <br>
* Объединение подответов полученных из подпроблем. <br>

---
<h2>* Как найти дубликаты в массиве </h2>

* https://stackoverflow.com/questions/7414667/identify-duplicates-in-a-list

  Один из интересных способов - использовать Set. Пример программы:

          Integer[] dateToTest = {1, 2, 2, 4, 4, 5, 6};

          final Set<Integer> setToReturn = new HashSet<>();
          final Set<Integer> set1 = new HashSet<>();

          for (Integer item : dateToTest) {
              boolean added = set1.add(item);
              if (!added) {
                  setToReturn.add(item);
              }
          }
          System.out.println(setToReturn);

--- 
<h2>* Деревья как структура данных. Какие виды деревьев существуют.</h2>

* https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
* https://medium.com/nuances-of-programming/%D0%B2%D1%81%D0%B5-%D1%87%D1%82%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%BE-%D0%B4%D1%80%D0%B5%D0%B2%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D1%8B%D1%85-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%D1%85-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-d750444a77ec

# TODO

Виды: <br>

* Сбалансированные/Несбалансированные
* Бинарные - иерархическая структура данных, в которой каждый узел имеет не более двух потомков (детей)
* Красно-черные деревья (балансируют себя сами)
* АВЛ-Дерево (AVL tree)
* ДБ-Дерево
* Сплей-Дерево (Splay tree)

---
<h2>* Алгоритмы сортировки</h2>
Алгоритм сортировки сортируют элементы в массиве с применением оператора сравнения. Основные алгоритмы сортировки: <br>

* <b>Bubble Sort</b> (Пузырьковая сортировка). Сложность - O(n2) <br>
  Самый простой алгоритм сортировки. Алгоритм сравниваем соседние элементы в массиве и меняет их местами в соответствии
  с результатом сравнения. Пузырьковая сортировка характеризуется низкой производительностью.
  <br>
* <b>Quick Sort</b> (Быстрая сортировка). Сложность - 0(n*log(n)) <br>
  Эффективный способ сортировки. Quick Sort - "Divide and Conquer" алгоритм (Разделяй и властвуй). Quick sort использует
  рекурсия для сортировки.
  <a href="https://medium.com/karuna-sehgal/a-quick-explanation-of-quick-sort-7d8e2563629b">Ссылка на статью</a><br>

Quick sort Explained.
![alt text](images/quick_sort.png)

* <b>Selection Sort</b> (Сортировка методом выбора). Сложность - O(n2)
  Один из простейших способов сортировки.<br>
  Порядок работы алгоритма:

1) Находим наименьший элемент в массиве и меняем его с первым элементом в массиве.
2) Далее находим следующий наименьший элемент или меняем его со вторым элементом в массиве.
3) Продолжаем процесс до последнего элемента в массиве.
   ![alt text](images/selection-short.png)

* <b>Insertion Sort</b> (Сортировка методом вставки)
  Алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый
  поступающий элемент размещается в подходящее место среди ранее упорядоченных элементов.
  ![alt text](images/insertion_sort.png)

* <b>Merger Sort</b> (Сортировка методом объединения). Сложность - O(n*logn). Алгоритм типа Разделяй и Властвуй.
  Алгоритм каждый раз разбивает массив на два массива. И так на каждом этапе разбивает древовидно до массивов с одним
  элементом. Далее происходит создание массива с упорядоченным порядком элементов.
  ![alt text](images/merge_sort.png)

Также существуют много других алгоритмов:

* Heap Sort;
* Counting Sort;
* Radix Sort;
* Bucket Sort;

---
<h2>* Критерии качества кода? </h2>

* соответствие правилам;<br>
* сложность кода;<br>
* дубликаты;<br>
* комментирование;<br>
* покрытие тестами.<br>

<p>1. <b>Соответствие правилам.</b> Java Code Conventions, GCC Coding Conventions, Zends Coding Standard. синтаксические правила — одни из наиболее бесполезных правил (но только первый взгляд), поскольку совсем никоим образом не виляют на исполнение программы. К ним можно отнести стиль именования переменных (camelCase, через подчеркивание), констант (uppercase), методов, стиль написания фигурных скобок и нужны ли они если в блоке только одна строка кода.  </p>
<p>2. <b>Цикломатическая сложность код.</b> Классы не должны быть слишком длинными, должны быть читаемы. То есть измеряется сложностью метода, класса, файла. </p>
<p>3. <b>Дубликаты.</b> Важная характеристика, которая отображает насколько легко в будущем (или настоящим) можно будет вносить изменения в код. Метрику можно означить в процентах как соотношение строк дубликатов к всем строкам кода. Чем меньше дубликатов тем легче будет жить с этим кодом.</p>
<p>4. <b>Комментирование.</b> Зависит от по большей части от правил компании, от соглашений программистов. Для маленьких проектов комментирование не столь необходимо, для больших же хорошо проработанные правила очень облегчат сопровождение.  </p>
<p>5. <b>Покрытие тестами.</b> Чем выше покрытие кода тестами тем меньше риск поломать часть системы и оставить это незамеченным.</p>

---
<h2>* Структура данных - Графы. breadth-first search (BFS). Поиск в ширину.</h2>

* https://en.wikipedia.org/wiki/Breadth-first_search

Поиск в ширину позволяет найти ближайшее расстояние между двумя элементами.
<br>
Поиск в ширину отвечает на следующие вопросы:

* Если ли путь от ноды A в ноду B
* Какой самый быстрый путь от ноды А в ноду B.

---
<h2>* CI/CD. Что это? Как работает?</h2>

* https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment

Это методика разработки и интеграции приложения. CI/CD - Continuous Integration, Continuous Delivery.  <br>
CI/CD — это комбинация непрерывной интеграции <b>(continuous integration)</b> и непрерывного развертывания <b>(
continuous delivery или continuous deployment)</b> программного обеспечения в процессе разработки

CI позволяет выполнять билды, запускать тесты на эти билды и тем самым позволяет обнаружить потенциальные ошибки к новом
написанном коде. CD это уже следующий шаг после создания билда. Это автоматизация процесса деплоя приложение в
необходимое окружение: <b>test, development, production</b>.

Автоматизированные процессы помогают значительно снизить трудозатраты разных отделов предприятия. Без автоматизации
CI/CD могут всплывать ошибки, вызванные человеческим фактором и необходимостью совершения ручных операций.

---
<h2>* Команды в Git "git pull", "git fetch". Различия.</h2>
Pull содержит в себе две команды: fetch + merge.

---
<h2>* Команда git stash</h2>

* https://www.freecodecamp.org/news/git-stash-explained/#:~:text=Retrieve%20Stashed%20Changes,the%20files%20from%20the%20stash

Представим мы работаем над какой-то проблемой и вдруг нам нужно пока остановить ее и поработать над чем-то другим.

1) git stash save "optional message for yourself" - сохранить изменения в stash
2) git stash list - посмотреть какие есть сохранения в stash
3) git stash apply STASH-NAME - извлечение изменений из stash-а, данные в stash сохраняются
4) git stash pop STASH-NAME - извлечение изменений из stash-а, данные в stash удаляются
5) git stash drop STASH-NAME - удаление stash-а

---
<h2>* Разница между командами git merge vs get rebase</h2>

git merge/rebase преследуют одну цель - они предназначены для интеграции изменений из одной ветку в другую.

<b>git merge (слияние)</b><br>
Слияние — обычная практика для разработчиков, использующих системы контроля версий. Независимо от того, созданы ли ветки
для тестирования, исправления ошибок или по другим причинам, слияние фиксирует изменения в другом месте. Слияние
принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка.
История исходных веток остается неизменной.

<b>git rebase (перемещение)</b><br>
Rebase — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем
он интегрирует патч в целевую ветку.

---
<h2>* Методы Object.</h2>

* <b>getClass</b> - возвращает объект класса Class, который содержит информацию о классе, который был вызван
* <b>hashCode</b> - возвращает адрес объекта в памяти. Для получения хэшкода используется процесс который называется
  хэшированием. Использование хэшей особенно полезня для более быстрой навигации в HashTable. Тут важный термин - это
  Collision (Коллизия). Два одинаковых равных объекта должны иметь одинаковые хэши. Однако неодинаковые объекты в
  результате процесса хэширования могут иметь одинаковые хэши. Это процесс Коллизии.

      public native int hashCode();

  Реализация нативная.

* <b>equals</b> - == - сравнивает ссылки. equals - можно в ней реализовать сравнение значений.

      public boolean equals(Object obj) {
      return (this == obj);
      }  


* <b>clone</b>
* <b>toString</b> - возвращает полное название класса + @ + шестнадцатеричное представление ячейки памяти объекта.
  Пример: com.adammcquistan.object.Person@458ad742

      public String toString() {
      return getClass().getName() + "@" + Integer.toHexString(hashCode());
      }  

* <b>notify</b>
* <b>notifyAll</b>
* <b>wait</b>
* <b>finalize</b>

---
<h2>* Модификаторы доступа</h2>

* private (область действия класса);<br>
* default, package-default (область действия внутри пакета) <br>
* protected (область действия внутри пакета + наследники);
* public (доступ везде);

---
<h2>* Принципы ООП. </h2>

* <b>Абстракция</b> <br>
  Если посмотреть на самый современный и на самый первый телефон, можно сразу выделить самые важные детали, которые
  важны и для устройства конца 19-го века, и для суперсовременного смартфона. Это совершение вызова (набор номера) и
  приём вызова. По сути это то, что делает телефон телефоном, а не чем-то другим. Сейчас мы применили принцип в ООП —
  выделение наиболее важных характеристик и информации об объекте. Этот принцип ООП называется абстракцией.<br>
* <b>Инкапсуляция</b> <br>
  Для исключения подобного вмешательства в конструкцию и работу объекта в ООП используют принцип инкапсуляции – еще один
  базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация
  объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс.

  public class SomePhone {

        private int year;
        private String company;
        public SomePhone(int year, String company) {
            this.year = year;
            this.company = company;
        }
        private void openConnection(){
            //findComutator
            //openNewConnection...
        }
        public void call() {
            openConnection();
            System.out.println("Вызываю номер");
        }
    
        public void ring() {
            System.out.println("Дзынь-дзынь");
        }

  }

* <b>Наследование</b> <br>
  В программировании наследование заключается в использовании уже существующих классов для описания новых. Использование
  принципа наследование ООП позволяет значительно уменьшить объем кода, а значит, и облегчить работу программисту. С
  помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или
  изменения старого.
* <b>Полиморфизм</b> <br>
  Принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем
  устройстве объекта, называется полиморфизмом.
  <br>
  Полиморфизм - "много форм". <br>
  Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и
  того же интерфейса для задания единого набора действий.

  public class User { private String name;

        public User(String name) {
            this.name = name;
        }
    
        public void callAnotherUser(int number, AbstractPhone phone) {
  // вот он полиморфизм - использование в коде абстактного типа AbstractPhone phone!
  phone.call(number); } }

  public class ThomasEdisonPhone extends AbstractPhone {

        public ThomasEdisonPhone(int year) {
            super(year);
        }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Вращайте ручку");
            System.out.println("Сообщите номер абонента, сэр");
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Телефон звонит");
        }
  }

  public class Phone extends AbstractPhone {

        public Phone(int year) {
            super(year);
        }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Вызываю номер" + outputNumber);
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("Телефон звонит");
        }
  }

  public class VideoPhone extends AbstractPhone {

        public VideoPhone(int year) {
            super(year);
        }
    
        @Override
        public void call(int outputNumber) {
            System.out.println("Подключаю видеоканал для абонента " + outputNumber);
        }
    
        @Override
        public void ring(int inputNumber) {
            System.out.println("У вас входящий видеовызов..." + inputNumber);
        }
  }

  Создадим объекты в методе main() и протестируем метод callAnotherUser:

  AbstractPhone firstPhone = new ThomasEdisonPhone(1879); AbstractPhone phone = new Phone(1984); AbstractPhone
  videoPhone=new VideoPhone(2018); User user = new User("Андрей"); user.callAnotherUser(224466,firstPhone); // Вращайте
  ручку //Сообщите номер абонента, сэр user.callAnotherUser(224466,phone); //Вызываю номер 224466 user.callAnotherUser(
  224466,videoPhone); //Подключаю видеоканал для абонента 224466

Используя вызов одного и того же метода объекта user, мы получили различные результаты. Выбор конкретной реализации
метода call внутри метода callAnotherUser производился динамически на основании конкретного типа вызывающего его объекта
в процессе выполнения программы. В этом и заключается основное преимущество полиморфизма – выбор реализации в процессе
выполнения программы.

* Примеры (перегрузка) - когда один метод можно определить несколькими способами в зависимости от типа входных данных.
  Тут принцип один интерфейс - много методов.
* Переопределение при наследовании от родительского класса. <br>
  Пример: Dancer breakDanceDancer = new BreakDankDancer("Алексей", 19); То есть мы может абстрагироваться как был создан
  наш объект, главное тут что этот объект наследник Класс/Интерфейса Dance и позволяет нам выполнять необходимые нам
  задачи без необходимости копаться в классе наследнике.

---
<h2>* Как запретить наследования для Класса</h2>
Запретить наследование с помощью ключевого слова final.

---
<h2>* Можно ли наследовать множество классов?</h2>
На самом деле если извратиться можно. Например в анонимных классах применить extends.

---
<h2>* Ключевое слово final</h2>

* Класс - для класса это означает что класс не сможет иметь подклассов, т.е запрещено наследование. Для abstract классов
  нельзя использовать модификатор final.
* Метод - этот метод нельзя переопределить в классах наследниках.
* Примитивный тип (int, float etc) - присвоенное значение не может быть изменено.
* Ссылочные переменные (Integer, Float, Double etc) - После присвоения объекта, нельзя изменить ссылку на объект.

---
<h2>* Mutable vs Immutable Objects in Java</h2>
Mutable объект может быть изменен после создания. Immutable - нельзя изменять. String - immutable в Java. Остальные типы
mutable - изменяемые.

- --
<h2>* Почему запрещена множественное наследование в Java. </h2>
<b>Множественное наследование</b> - способность создавать классы с множеством классов-родителей. <br>
Проблема может быть в том, если наследоваться от нескольких классов и использовать какой-нибудь метод, который определен
в классах-родителях, в этом случае компилятор не знает о том, метод какого именно суперкласса должен быть вызван. В этом
основная причина.

---
<h2>* На какие области делится память JVM</h2>

* <b>Stack </b><br>
  Хранит примитивы, ссылки на объекты, хранит локальные переменные. <br>
  Из-за простоты распределения памяти, стековая память работает немного быстрее хипа. Размер меньше, чем у Heap.
* <b>Data Heap</b> <br>
  Динамически распределенная опер. память. RAM. Используется для JRE классов и размещения объектов.
  <br><br>
  <i>Основные выводы:</i>
* Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.
* Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память
  стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
* Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других
  потоков.
* Управление памятью в стеке осуществляется по схеме LIFO.
* Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы
  программы.
* Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека
  определить размер памяти можно с помощью опции -Xss .
* Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи
  заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.
* Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает
  намного быстрее кучи.

---
<h2>* Чем отличается JRE, JVM, JDK</h2>

<p>
JDK - Java Development kit. Комплект разработчика на Java, включает javac, стандартные библиотеки, документацию, примеры + JRE для запуска написанных программ.
При установке JDK будет установлен JRE. 
</p>
<p>
    JRE - Java RunTime Environment. Минимальная реализация виртуальной машины, необходимая для исполнения Java приложений, без компилятора и т.д. Состоит из виртуальной машины - JVM и библиотек Java-классов
</p>
<p>
    JVM - Java Virtual Machine. JVM -  основная часть JRE. Виртуальная машина интерпретирует байт код. 
</p>

Принцип работы Java-программ:

* Пишем нашу программу. Наша программа имеет расширение .java;
* Далее с помощью компилятора компилируем Java-код к байт код (байт код будет запускаться Java виртуальной машиной.
  Виртуальная машина переводит байт-код в машинный код. );
* В результате компилирования у нас появляется файл с расширение .class;
* Запускаем скомпилированный файл. Команда (java НазваниеФайлаБезРасширения).

---
<h2>* Java Packaging. Пакетирование в Java</h2>
Существуют следующие виды упаковок в Java <br>

* .jar - Java архив. Это Zip файл, содержащий один или несколько Java классов.
* .war - Web Application Archive - Zip файл, содержащий веб-приложение. Включает один и более jar-файлов, Java-классы и
  веб-ресурсы.
* .ear - Enterprise Archive - Zip файл, содержащий много WAR файлов.
* Fat Jar - Jar файл, содержащий все зависимости
* Docker Container - Image, содержащий JVM, Java пакеты и т.д.

---
<h2>* Для чего в джава статические блоки? </h2>
<p>Статические блоки в джава выполняются до выполнения конструктора , с помощью них инициализуют статические поля.</p>
Статические блоки инициализация используются для выполнения кода, который должен выполняться один раз при инициализации класса загрузчиком классов, в момент, предшествующий созданию объектов этого класса при помощи конструктора. Такой блок (в отличие от нестатических, принадлежащих конкретном объекту класса) принадлежит только самому классу (объекту метакласса Class).


---
<h3>* Бывают ли приватные конструкции, где используются?</h3>
Да бывают. Например, singleton.

---
<h2>* Что такое перегрузка методов? Можно ли перегрузить static методы?</h2>
<p>В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).</p>
<p>Статические методы можно перегружать нестатическими и обратно - без ограничений. </p>

---
<h2>* Приведите пример когда можно использовать статический метод?</h2>
<p>Статические методы применяются например для инициализации статических переменных. </p>

---
<h2>* Что такое загрузчик классов в Java? Какие бывают? Статическая и динамическая загрузка классов? </h2>
Загрузчик классов используется для поставки в JVM скомпилированного байт-кода, который, как правило, хранится в файлах с
расширением .class<br>
Реализуя наследников ClassLoader, можно полностью контролировать процесс загрузки абсолютно всех Java-классов. <br>
Можно загружать их из любого источника, к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из базы
данных или из Internet. <br>
Можно предоставить загрузку стандартных библиотечных классов системному загрузчику, но при этом протоколировать факт
обращения к ним. <br>

Бывают 3 типа загрузчиков<br>

* Базовый загрузчик - загружает стандартные классы JDK из архива rt.jar<br>
* Загрузчик расширений - загружает классы расширений, которые по умолчанию находятся в каталоге jre/lib/ext, но могут
  быть заданы системным свойством java.ext.dirs <br>
* Системный загрузчик - загружает классы приложения, определенные в переменной среды окружения CLASSPATH.

Загрузчик расширений и системный загрузчик наследуют абстрактный класс ClassLoader. Базовый загрузчик уже реализован
нативно внутри Java.<br>
ClassLoader - самый низкоуровневый, «глубинный» механизм Java, позволяющий вмешиваться практически в ядро Java-машины,
причем оставаясь в рамках программирования на Java.
<br>
Реализуя наследников ClassLoader, можно полностью контролировать процесс загрузки абсолютно всех Java-классов. Можно
загружать их из любого источника, к примеру, из собственной системы каталогов, не отраженной в CLASSPATH, из базы данных
или из Internet.

<br><br>
<i>Статическая загрузка класса </i> происходит при использовании оператора "new"<br>
<i>Динамическая загрузка класса </i> происходит на лету, с помощью статического метода класса Class.forname(имя класса).
Динамическая загрузка нужна когда нужен неизвестный класс(то есть еще сам класс еще не определен), и загрузка это класс
происходит в ходе выполнения программы.

---
<h2>* Статический класс. Особенности</h2>

* https://stackoverflow.com/questions/7486012/static-classes-in-java

Статическим классом может быть только класс внутри класса. Статические классы используются как утилитарные классы,
например для получения доступа к константам и утилитным методам.

---
<h2>* Каким образом передаются переменные в методы, по значению или по ссылке?</h2>
<p>В java переменные в методы передаются по значению. То есть создаются копии параметров и работа происходит с ними. </p>
<p>При передачи объекта копируется ссылка на него. И если в методы мы изменим состояние объета, то и за методом это состояние объекта изменится. Однако если мы изменим ссылку на объект, то то старая ссылка не изменится. </p>

---
<h2>* Расскажите про клонирование объектов. В чем отличие поверхностного от глубокого клонирования? </h2>
<p>Чтобы объект можно было клонировать, необходимо реализовать интерфейс Cloneable (маркер). </p>
<p>Поверхностное клонирование - клонируются только примитивные поля, ссылочные поля не клонируются</p>
<p>Глубокое клонирование - клонируются еще ссылки. Для этого необходимо переопределить <b>метод clone</b> и в нем произвести клонирование изменяемых полей объекта. </p>

* https://www.geeksforgeeks.org/cloneable-interface-in-java/

Если класс не реализует Cloneable, то при попытке клонирования объекта выскочит <b>CloneNotSupportedException</b>.

---
<h2>* Какие виды исключений вы знаете? Checked vs unchecked Exceptions?</h2>

* https://www.baeldung.com/java-checked-unchecked-exceptions

Все исключения являются потомками класса <b>Throwable</b>.

<i>unchecked exception</i> - наследники классов Error и RunTimeException, <br>
<i>checked exception</i> - наследники Throwable и Exception.
<br><br>
<b>Примеры unchecked exception Error</b>: OutOfMemoryError, StackOverFlowError, LinkageError<br>
<b>Примеры unchecked exception RunTimeException</b>: IndexOutOfBoundsException, ArithmeticException,
IllegalArgumentException<br>

Примеры checked Exception: IO Exception (FileNotFoundException), SocketException<br>
Java проверяет checked exceptions в момент компиляции и с этими эксепшами используется ключевое слово "throws",
Unchecked exception не проверяются в момент компиляции, они могут возникнуть в момент работы приложения.

<br>
Что значит “проверяемые”? ...компилятор Java знает о самых распространенных исключениях, и знает, в каких ситуациях они могут возникнуть”. Поэтому компилятор заранее проверяет наш код на наличие потенциальных исключений. Если он их найдет, то не скомпилирует код, пока мы не обработаем их или не пробросим наверх. Поэтому они проверяемые. 
<br>
Непроверяемые исключения.  компилятор явно не в силах предусмотреть все возможные неправильные ситуации, которые люди могут создать своими руками :) Поэтому он не будет проверять обработку таких исключений в нашем коде. Поэтому непроверяемые. 

---
<h2>* Может ли абстрактный класс быть final? </h2>
Нет, не может. Ключевое слово final означает, что класс на вершине иерархии, и у него не может быть наследников. А
абстрактный класс без наследников — это сферический конь в вакууме, так как нельзя создать экземпляр abstract class.

Таким образом, если класс одновременно abstract и final, то у него нет наследников и нельзя создать его экземпляр.
Компилятор Java выдаст ошибку, если сделать класс одновременно abstract и final.

---
<h2>* Могут ли у абстрактного класса в языке Java быть статические методы? Можно ли переопрелять статические
методы? </h2>
Да, абстрактные классы могут объявлять и определять статические методы. Только необходимо следовать общим принципам
создания статических методов в Java, поскольку они нежелательны при объектно-ориентированном проектировании, ведь
переопределение статических методов в Java невозможно. Однако вместо переопределения можно скрывать статические методы.

---
<h2>* Что такое абстрактный метод?</h2>
Абстрактный метод – это метод без тела. Вы просто объявляете метод, не определяя его, с использованием ключевого слова
abstract в объявлении метода. Все объявленные внутри интерфейса в языке Java методы – по умолчанию абстрактные.

---
<h2>* Может ли абстрактный класс в Java содержать метод main?</h2>
Да, абстрактный класс в Java может содержать метод main, ведь это просто еще один статический метод, и абстрактный класс
можно выполнять при помощи метода main, если не создавать его экземпляров.

---
<h2>* Что такое интерфейс. Особенности.</h2>
Ключевое слово interface используется для создания полностью абстрактных классов. Основное предназначение интерфейса -
определять каким образом мы можем использовать класс, который его реализует. Создатель интерфейса определяет имена
методов, списки аргументов и типы возвращаемых значений, но не реализует их поведение. Все методы неявно объявляются как
public.

Начиная с Java 8 в интерфейсах разрешается размещать реализацию методов по умолчанию default и статических static
методов.

Интерфейс также может содержать и поля. В этом случае они автоматически являются публичными public, статическими static
и неизменяемыми final.

---
<h2>* Внутренние классы</h2>
Эти классы создаются внутри других классов.

Виды:

* Non-static nested classes — нестатические вложенные классы.
* Static nested classes — статические вложенные классы.

В свою очередь, внутренние классы (inner classes) имеют два особых подвида. Помимо того, что внутренний класс может быть
просто внутренним классом, он еще бывает:
локальным классом (local class)
анонимным классом (anonymous class)

Вложенные (nested) классы должны создаваться только для того, чтобы обслуживать обрамляющий класс. Если вложенный класс
оказывается полезен в каком-либо ином контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ
ко всем (в том числе приватным) полям и методам внешнего класса, но не наоборот.

---
<h2>* Mutable / inmutable типы данных</h2>

* https://www.interviewcake.com/concept/java/mutable#:~:text=A%20mutable%20object%20can%20be,an%20immutable%20object%20can't.&text=That%20said%2C%20if%20you're,all%20fields%20final%20and%20private.&text=Strings%20are%20immutable%20in%20Java
  .

Mutable - изменяемый тип данных. Может быть изменен после создания. <br>
Immutable - неизменяемый тип данных.

В Java Immutable только String, остальные типы данные изменяемые - Mutable.




--- 
<h2>* Try with resources</h2>

Try with resources был представлен в 7 версии Java. Позваляет использовать ресурсы в блоке try c гарантией того что
после блока try ресурсы будут закрыты. Ресурсы должны обязательно имплементировать интерфейс AutoCloseable.

Пример:

      try (Scanner scanner = new Scanner(new File("test.txt"))) { <br>
      while (scanner.hasNext()) {<br>
      System.out.println(scanner.nextLine());<br>
      }<br>
      } catch (FileNotFoundException fnfe) {<br>
      fnfe.printStackTrace();<br>
      }

---
<h2>* Autoboxing. Что это? Особенности Autoboxing. </h2>
Autoboxing - автоупаковка, unboxing - распаковка. Autoboxing был внесен в JDK 5. <br>
<b>Автоупаковка</b> - это автоматическая инкапсуляция примитивного типа в эквивалентную ему класс-обертку всякий раз,
когда это требуется.<br>
То есть int -> Integer, double -> Double, char -> Character, boolean -> Boolean. <br>
<b>Автораспаковка</b> - это обратный процесс. Преобразование класса-обертки в примитивный тип.<br>
При автораспаковке может произойти исключение java.lang.NullPointerException в случае если значение класса-обертки было
= null.

Старый способ получения примитивного типа - это применение методов intValue(), doubleValue() и т.д в классах-обертках.
Раньше до JDK 5 приходилось использовать старый подход, но из-за этого снижалась читаемость кода. Но благодаря
autoboxing, autounboxing конвертировать из примитива в класс-обертку и обратно уже не нужно.

---
<h2>* Integer.valueOf() vs Integer.parseInt(). Разница. </h2>

ValueOf(String) возвращает объект new Integer(), тогда как parseInt(String) возвращает примитив int. parseInt()
возвращает примитивное целое число type (int), в результате чего valueOf возвращается java.lang.Integer, который
является объектом представитель целого числа. Там являются обстоятельствами, в которых вы, возможно, захотите объект
Integer, вместо примитивный тип.

Между этими способами нет различий в производительности.


---

# <a name="java_collections"></a>

<h1>*** Что такое Java Collections. Иерархия интерфейсов.</h1>
Java Collections Framework - это иерархия интерфейсов и их реализаций, которая является частью JDK и позволяет разработчику пользоваться большим количеством структур данных из под коробки. 

На вершине иерархии располагаются 2 интерфейса: <b>Collection, Map.</b><br>
Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые
последовательные наборы элементов и наборы пар "ключ - значение" (словари).
<br>

<b>Интерфейс Collection</b> - определяет основные методы работы с простыми наборами элементов, которые будут общими для
всех его реализаций. Методы: size(), isEmpty(), add(E e) и др). С приходом стримов еще добавились методы stream(),
parallelStream, removeIf();
<br>Все эти методы реализованы в интерфейсе как default-методы.

<b>Интерфейс Map</b> - предоставляет базовые методы для работы с данными вида "ключ - значение".

Наследники интерфейса <b>Map</b>:

* HashTable - хэш таблица. Нельзя использовать null в качестве значения или ключа. В этой таблице все методы реализованы
  как synchronized, поэтому есть проблемы с производительностью. Рекомендуется использовать другие реализации интерфейса
  Map.
* HashMap - альтернатива HashTable. Основные отличия от HashTable методы не синхронизованы и HashMap позволяет
  использовать null как в качестве ключа, так и значения.
* LinkedHashMap - это упорядоченная реализация хэш-таблицы. Здесь в отличии от HashMap, порядок итерирования равен
  порядку добавления элементов.
* TreeMap - реализация Map основанная на красно-черных деревьях. Как и LinkedHashMap является упорядоченной.
  По-умолчанию, коллекция сортируется по ключам.
* WeakHashMap - реализация хэш таблицы, которая организована с использованием weak references. Garbage Collector
  автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жестких ссылок.

Наследники интерфейса <b>Set</b> (Сам Set имплементится от Collections interface):

* HashSet - реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В
  качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за
  особенностей реализации порядок элементов не гарантируется при добавлении.
* LinkedHashSet - отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому
  отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов.
* TreeSet - аналогично другим классам-реализациям интерфейса Set содержит в себе объект NavigableMap, что и
  обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта
  Comparator, либо сохраняет элементы с использованием "natural ordering".

Наследники интерфейса <b>Queue</b> (Сам Queue имплементится от Collections interface):
Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (
first-in-first-out). Помимо методов, определённых в интерфейсе Collection, определяет дополнительные методы для
извлечения и добавления элементов в очередь.

* PriorityQueue - является единственной прямой реализацией интерфейса Queue,
* ArrayDeque - реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать
  конструкцию вида LIFO (last-in-first-out). Интерфейс Deque и реализация ArrayDeque были добавлены в Java 1.6. Эта
  коллекция представляет собой реализацию с использованием массивов, подобно ArrayList, но не позволяет обращаться к
  элементам по индексу и хранение null.

---
<h2>* Основные интерфейсы коллекций и их имплементации. </h2>

* Основные интерфейсы: List, Set, Queue; Map к коллекциям не относится, т.к. это совокупность пар ключ-значение.  
  <br>
  <b>List</b>: имеет следующие реализации: ArrayList (удобна в навигации), LinkedList (быстра в вставке и удалению
  элементов), Vector(синхронизован. работает медленнее в одном потоке.);
  <br>
  <b>Set</b>: HashSet (упорядочивание по хэш-ключам), TreeSet (упорядоченный сет), LinkedHashSet (хранит элементы в
  порядке их добавления);
  <br>
  <b>Queue</b>: PriorityQueue;
  <br>
  <b>Map</b>: HashTable (синхронизована, уже устаревшая), HashMap (порядок по хэш ключу), HashTree (порядок в
  отсортированном порядке), LinkedHashMap( в порядке вставки), ConcurrentHashMap (потокобезопасный map).

---
<h2>* ArrayList vs LinkedList</h2>
<p> В <i>LinkedList</i> элементы фактически представляют собой звенья одной цепи. У каждого элемента помимо тех данных, которые он хранит, имеется ссылка на предыдущий и следующий элемент. По этим ссылкам можно переходить от одного элемента к другому. </p>

Вся работа с ArrayList (по большому счету) сводится к работе с внутренним массивом. Вся работа с LinkedList сводится к
изменению ссылок.

Общие методы: add(), remove(), indexOf(), clear(), contains(), size(). Методы только у LinkedList: addFirst(), addLast()

- методы для добавления элемента в начало/конец списка.

---
<h2>* Интерфейс Queue</h2>
Интерфейс Queue расширяет Collection и объявляет поведение очередей, которые представляют собой список с дисциплиной "
первый вошел, первый вышел" (FIFO). Существуют разные типы очередей, в которых порядок основан на некотором критерии.
FIFO - First In, First Out;

---
<h2>* BlockingQueue </h2>
Интерфейс BlockingQueue наследует свойства интерфейса Queue;

Реализация данного интерфейса обеспечивает блокировку потока в двух случаях:<br>
Когда поток пытается получить элемент из пустой очереди, то он переводится в состояние ожидания до тех пор, пока
какой-либо другой поток не разместит элемент в очереди.

Аналогично при попытке положить элемент в полную очередь; поток ставится в ожидание до тех пор, пока другой поток не
заберет элемент из очереди и, таким образом, не освободит место в ней. Естественно, понятие "полная очередь"
подразумевает ограничение размера очереди. BlockingQueue изящно решает проблему передачи собранных одним потоком
элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.

---
<h2>* Как устроен HashMap.</h2>
HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки
на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого
вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее
сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по
ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный
элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

---
<h2>* Как расчитывается index bucket-а по hashCode?</h2>

* https://facingissuesonit.com/tag/hashmap-index-calculation-formulae/

Используется побитовая операция умножения. Index = hashcode(Key) & (n-1), где n - размер массива.

---
<h2>* ConcurrentHashMap vs HashMap</h2>
<p>
ConcurrentHashMap был представлен как альтернатива Hashtable в Java 1.5 как часть пакета многопоточности. C ConcurrentHashMap у вас есть лучший выбор, не только потому, что это безопасно в многопоточном окружении, но так же предоставляет лучшую производительность по сравнению с Hashtable и synchronizedMap. ConcurrentHashMap работает производительнее, потому что блокирует лишь часть Map. Позволяет одновременные операции чтения и в тоже время обеспечивает целостность, синхронизируя операции записи.
ConcurrentHashMap отлично подходит, когда у вас множество читающих потоков и несколько пишущих. 
</p>

---
<h2>* Особенности HashSet</h2>

* https://javarush.ru/groups/posts/2147-hashset-v-java

Класс HashSet реализует интерфейс Set, основан на хэш-таблице, а также поддерживается с помощью экземпляра HashMap. В
HashSet элементы не упорядочены, нет никаких гарантий, что элементы будут в том же порядке спустя какое-то время.
Операции добавления, удаления и поиска будут выполняться за константное время при условии, что хэш-функция правильно
распределяет элементы по «корзинам», о чем будет рассказано далее.

Особенности:

* Т.к. класс реализует интерфейс Set, он может хранить только уникальные значения;
* Может хранить NUll - значения;
* Порядок добавления элементов вычисляется с помощью хэш-кода;
* HashSet реализует интерфейсы Serializable и Cloneable;

<HashSet> не является структурой данных с встроенной синхронизацией, поэтому если с ним работают одновременно несколько потоков, и как минимум один из них пытается внести изменения, необходимо обеспечить синхронизированный доступ извне.
Часто это делается за счет другого синхронизируемого объекта, инкапсулирующего HashSet. 
Если такого объекта нет, то лучше всего подойдет метод Collections.synchronizedSet(). 
На данный момент это лучшее средство для предотвращения несинхронизированных операций с HashSet.

---
<h2>* Разница между TreeMap и TreeSet</h2>

* https://www.java67.com/2012/08/difference-between-treemap-and-treeset-java.html#:~:text=TreeSet%20vs%20TreeMap%20in%20Java&text=TreeSet%20stores%20only%20one%20object,later%20implements%20NavigableMap%20in%20Java

Общее:

* Обе структуры имеют сортировку (естественная сортировка либо кастомная сортировка через интерфейс Comparator)
* Общий предок интерфейс Collection;
* Treeset заимлементен через TreeMap;
* Оба интерфейса не синхронизованные;
* Одинаковая сложность алгоритмов O(log(n)) - красно-черные деревья.

Различия:

* TreeMap имплементирует интерфейс Map, TreeSet имплементирует Set;
* TreeMap содержит данные в формате ключ-значение, TreeSet хранит объекты;
* TreeMap имплементирует NavigableMap, Treeset - NavigableSet;
* TreeMap позволяет дубликаты, в Treeset дубликатов не должно быть;

---
<h2>* Comparable and Comparator</h2>
Comparable - если хотим сравнивать объекты, то достаточно заимплементить интерфейс Comparable в классе и переопределить
метод compareTo.<br>
Comparator - это отдельный класс Компаратора, в котором описывается вся логика сравнения объектов. Компаратор позваляет
сохранять исходный код объекта, не изменять default метод сортировки. Очень удобно.
<br>
<a href="https://javarush.ru/groups/posts/2262-comparator-v-java?post=full#discussion">Полезная ссылка</a>

--- 
<h2>* Class Enum. Constant specific class body. </h2>
<a href="https://explained.blog/java/using-enum-and-constant-specific-class-body-in-java/">Ссылка на источник</a><br>

Пример обычного enum-а:

        enum Day {
        SUNDAY,
        MONDAY,
        TUESDAY,
        WEDNESDAY,
        THURSDAY,
        FRIDAY,
        SATURDAY
        };

Enum создан для того, чтобы ограничить кол-во принимаемых значений параметра. Например - дни недели (их 7 шт, других не
должно быть).
<br> Однако Enum также может иметь атрибуты и методы. Приведем пример ниже:

    enum Day {
        SUNDAY(1),
        MONDAY(2),
        TUESDAY(3),
        WEDNESDAY(4),
        THURSDAY(5),
        FRIDAY(6),
        SATURDAY(7);
        
        int position;
    
        Day( int position ) {
            this.position = position;
        }
    
        public int getPosition() {
            return this.position;
        }
    }

    public class Example {
        public static void main( String ... args ) {
    
            Day day = Day.SUNDAY;
            System.out.println( "Position is " + day.getPosition() );   /* Position is 1 */
    
        }
    }

Однако предположим что мы хотим получить кол-во рабочих часов в каждом дне. Однако в этом случае, например, люди
работают только в будние дни (то есть 9 часов в сумме) и в выходные отдыхают (Суббота-Воскресенье - 0 часов). Для этого
случая были придуманы Constant specific class body.

        enum WorkingHours {
            SUNDAY {
            public int getWorkingHours() {
            return 0;
            }
            },
            MONDAY,
            TUESDAY,
            WEDNESDAY,
            THURSDAY,
            FRIDAY,
            SATURDAY{
            public int getWorkingHours() {
            return 0;
            }
            };
        
            public int getWorkingHours() {
                return 9;
            }
        }
        
        public class Person {
        public static void main( String ... args ){
        WorkingHours day = WorkingHours.MONDAY;
        System.out.println( "Today is " + day + " and i have " + day.getWorkingHours() + " working hours today." );
        // Today is MONDAY and i have 9 working hours today.
        
                day = WorkingHours.SUNDAY;
                System.out.println( "Today is " + day + " and i have " + day.getWorkingHours() + " working hours today." );
                // Today is SUNDAY and i have 0 working hours today.
            }
        }

---
<h2>* Что такое сокет. Класс Socket. Для чего нужен? </h2>
Сокет нужен для получения соединения между двумя машинами. Например, чтобы получить связь между клиентом и сервером.
Одна сторона считывает данные, другая сторона записывает данные и наоборот. Class Socket имплементит интерфейс
Closeable (то есть через метод close можно закрыть соединение между клиентом и сервером).

---

# <a name="stream_api"></a>

<h1>*** STREAMS, STREAM API</h1>

--- 
<h2>* Что такое функциональное программирование</h2>
Функциональное программирование - это парадигма программирования (стиль написания компьютерных программ) посредством
реализации математических функций.
<br><b>Функциональные языки</b>: Haskell (самый старый), Erlang, Scala, Clojure.
<br>
Принципы функционального программирования:<br>

* Pure Functions (Чистые функции) - с одним и теми же входными данными должен получаться одинаковый результат.
  <br>
* No side effects (Никаких побочных эффектов) - Side effects - это изменение отличного от функции, которая исполняется в
  текущий момент. Пример: вывод в консоль, вызов исключения, чтение данных из файла - все это примеры побочных эффектов,
  которые лишают функцию чистоты.
  <br>
* Переменные неизменяемы - В функциональном программирование вы не можете изменить переменную после ее инициализации. Вы
  можете создавать новые, но не можете изменять существующие - и благодаря этому можно быть уверенным, что никакая
  переменная не изменится.
  <br>
* Относительная прозрачность функций - Если можно заменить вызов функции на возвращаемое значение, и состояние при этом
  не изменится, то функция относительно прозрачна.
  <br>
* Все функции - первого класса и высшего порядка.

---
<h2>* Что такое лямбда. Что такое функциональный интерфейс.</h2>
Лямбда выражения - это шаг Java к функциональному программированию.<br>
Лямбда выражения пришли взамен анонимным классам. Лямбда выражения походи на анонимные классы, но они более понятны и
быстро реализуются.
<br> Лямбда выражения - это анонимные функции, которые реализованы через Функциональные интерфейсы.
<br> Функциональные интерфейсы имеют аннотацию @FunctionalInterface". Любой интерфейс с одним абстрактным методом (
Single Abstract Method) является функциональным интерфейсом. Добавление аннотации @FunctionalInterface не обязательно,
но при наличии данной аннотации код не скомпилируется, если будет больше или меньше, чем 1 абстрактный метод. <br>

В JAVA есть встроенные функциональные интерфейсы. Они находятся в пакете <b>java.util.function</b>.

Приведем пример как реализовались задачи по Стримов и после.
<br>
Задача: Отсортировать Список слов по длине.<br>

* Как это делалось до Стримов:

        Collections.sort(words, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return Integer.compare(o1.length(), o2.length());
            }
        });

* Со Стримами

        Collections.sort(words2, (w1, w2) -> Integer.compare(w1.length(), w2.length())) ;

* Со Стримами еще короче

        Collections.sort(words2, Comparator.comparingInt(String::length)) ;

---
<h2>* Основные встроенные функциональные интерфейсы. </h2>
Как было сказано встроенные функциональные интерфейсы представлены в пакете <b>java.util.function</b>. В данном пакете
представлены интерфейсы, созданные для наиболее встречаемых задач.
<br>
Список основных встроенных функциональных интерфейсов:

* <b>Java Function</b> interface (java.util.function.Function):
  Является одним из центральных функциональных интерфейсов в Java. Метод этого интерфейса на вход принимает один
  параметр и возвращает одно значение.  
  <br>Пример интерфейса ниже:

        public interface Function<T,R> {
            public <R> apply(T parameter);
        }

* <b>Predicate Interface</b>. Принимает на вход один параметр, возвращает true/false.

        public interface Predicate {
        boolean test(T t);
        }

* <b>Supplier Interface</b>. Функциональный интерфейс, который ничего не потребляет, но предоставляет/возвращает данные.

* <b>Consumer Interface</b>. Функциональный интерфейс, который потребляем данные, но ничего не возвращает.

---
<h2>* Разница между Collections And Streams.</h2>
Коллекции содержат свои элементы, Stream не содержат. То есть Stream работает с Вьюхами никаким образом не изменяя
исходную Коллекцию.




---
<h2>* Stream API и лямбда выражения в Java</h2>
<a href='https://java-master.com/stream-and-lambda-in-java/'>Link</a>
<p>
Лямбда — выражение в программировании — специальный синтаксис для определения функциональных объектов, заимствованный из лямбда-исчисления. То есть, используя функциональные объекты, можно объявлять функции в любом месте кода. Stream API в Java8 используется для работы с коллекциями, позволяя писать код в функциональном стиле.<br>
В мире Java они появились в 8 версии и не остались незамеченными опытными программистами. Их очень хорошо применять Stream API.
</p>
Порядок работы с лямбда выражениями:<br>
* создать stream; <br>
* выполнить цепочку операций со stream (промежуточные операции - их еще называют lazy операции);<br>
* выполнить терминальную операцию (объединение коллекций, агрегирование и т.д);<br>
Во время использования лямбда выражений можно пользоваться промежуточные операциями бесчисленное множество раз. Терминальная операция может быть использована один раз.<br>

Примеры создания stream-а:
<p>Пустой стрим: Stream.empty()</p>
<p>Стрим из List: list.stream()</p>
<p>Стрим из Map: map.entrySet().stream()</p>
<p>Стрим из массива: Arrays.stream(array)</p>
<p>Стрим из указанных элементов: Stream.of("1", "2", "3")</p>

<a href="https://habr.com/ru/company/luxoft/blog/270383/">Очень полезная ссылка</a><br>
<b>Основные промежуточные операции лямбда выражений.</b>

* filter - фильтрация записей.
* skip - пропуск N записей.
* distinct - убирает дубликаты.
* map - выполнение операций над каждым элементом стрима.
* limit - ограничение выборки.
* sorted- сортировка значений либо в натуральном порядке, либо с применением Comparator.
* mapToInt, mapToDouble, mapToLong - аналог map, но возвращает числовой стрим.

<b>Основные терминальные операции лямбда выражений. </b>

* findFirst - возвращает первый элемент.
* collect - представление результата в виде коллекций или других структур данных.
* сount - возвращает кол-во элементов.
* anyMatch - возвращает true если условие выполняется хотя бы для одного элемента.
* noneMatch - возвращает true если условие не выполняется для всех элементов.
* min, max - минимальное и максимальное значение.
* forEach - применение функции к каждому элементу стрима. Порядок не гарантируется.
* forEachSorted - применение функции к каждому элементу стрима c сохранением порядка.
* reduce - позволяет выполнять агрегатные функции и возвращает один результат. (
  Пример: https://www.baeldung.com/java-stream-reduce)

---
<h2>* Параллельные стримы. Как работают параллельные стримы под капотом. ForkJoinPool. </h2>

* https://metanit.com/java/tutorial/10.9.php

<b>parallelStream</b> - это новый метод для работы со стримами в JDK8. <br>

Это способ использования Стримов используя параллельные потоки. Распараллеливание потоков позволяет задействовать
несколько ядер процессора (если целевая машина многоядерная) и тем самым может повысить производительность и ускорить
вычисления.<br>

Чтобы использовать параллельные стримы нужно использовать метод <b>parallel</b> объекта Stream либо использовать
метод <b>parallelStream()</b> интерфейса Collection.

Пример:<br>

    public static void main(String[] args) {
         
        Stream<Integer> numbersStream = Stream.of(1, 2, 3, 4, 5, 6);
        Optional<Integer> result = numbersStream.parallel().reduce((x,y)-> x*y);
        System.out.println(result.get()); // 720
    }

Однако не все функции можно без ущерба для точности вычисления перенести с последовательных потоков на параллельные.
Прежде всего такие функции должны быть без сохранения состояния и ассоциативными, то есть при выполнении слева направо
давать тот же результат, что и при выполнении справа налево.

Параллельные стримы извнутри используют ForkJoinPool. ForkJoinPool - специальный вид ExecutorService (пулла потоков),
предназначен для выполнения рекурсивных задач. <br>

Задача для сервиса представляется экземпляром класса ForkJoinTask.

---
<h2>* Разница между map и flatmap в Streams</h2>
<b>map и flatmap</b> оба используются для трансформации одного объекта в другой. Однако основное отличие flatmap от map
в том, что flatmap собирает все List of Lists в один List элементов.

---
<h2>* Что делает метод peek()</h2>
Метод peek() позволяет видеть/принтовать промежуточную результаты работы Стримов. Больше всего используется для
debugging проблем.

---
<h2>* ForkJoinPool, FixedThreadPool. Разница?</h2>

---

# <a name="generics"></a>

<h1>*** GENERICS</h1>

* https://habr.com/ru/company/sberbank/blog/416413/
* https://www.javacodegeeks.com/2013/07/java-generics-tutorial-example-class-interface-methods-wildcards-and-much-more.html

«Дженерики», доступные с Java 5, сделали использование Java Collection Framework проще, удобнее и безопаснее. Generics -
это технический термин, обозначающий набор свойств языка позволяющих определять и использовать обобщенные типы и методы.
Обобщенные типы или методы отличаются от обычных тем, что имеют типизированные параметры.

До генериков был высокий риск ClassCastException ошибки. С появлением дженериков теперь осуществляется проверка типов
данных в момент компиляции, таким образом минимизируется появлении ошибки ClassCastException.


---
---
---

# <a name="multithreading"></a>

<h1>*** MULTITHREADING. MAIN QUESTIONS</h1>
---
<h2>* Multithreading. Потоки. Для чего нужны? </h2>

Чтобы создать поток есть 3 способа: <br>
<b>src/main/java/learning_questions_answering/java_multithreading/ways_to_create_threads</b>

* отнаследоваться от класса Thread (MyThread extends Thread);
* заимплементить интерфейс Runnable и вставить инстанс класса в конструктор Thread класса (MyThread implements Runnable)
  ;
* создание потока через Анонимные классы;

Ключевые слова:

* <b>volatile</b> - это говорит потокам что это значение может изменяться другими потоками. Потоки как работают: обычно
  копируют переменные в кэш и работают с этими локальными переменными. Однако если переменная измениться, поток об этом
  может не узнать. Volatile-переменные предупреждает потоки, что они его не копировали и каждый раз когда к ней будут
  обращаться смотрели к главной копии этой переменной.
* <b>synchronized</b> - когда мы синхронизируем метод, это означает что доступ к методу параллельно имеет достип только
  строго один поток. И если другой поток видит, что метод занят, то он переходит в режим ожидания до тех пор пока мютекс
  метода не освободится.<br>
  Бывают синхронированные методы, синхронизованные блоки.  
  Ключевые методы на потоках:
* <b>join</b> - ждем пока поток не остановится.
* <b>wait</b> - останавливаем работу поток пока не поступит команда (может применяться только в блоке synchronized)
* <b>notify, notifyAll</b> - предупреждаем потоки что можно продолжить работу. Также применяется только в блоке
  synchronized.

---
<h2>* Что такое ThreadPool. Для чего используется?</h2>
Thread pool - пул тредов.<br>
<b>Example</b>: ExecutorService executorService = Executors.newFixedThreadPool(2);<br>
То есть через newFixedThreadPool создается пул из 2 потоков. То есть параллельно могут выполняться 2 потока. Запуск
потока происходит через команду executorService.submit(Runnable thread). Если в пуле уже 2 потока, то следующий поток
будет ждать пока есть освободиться место для него в executorService.

---
<h2>* Что такое семафора. Где используется? </h2>
Semaphore. Методы - Используется для контроля доступа к объекту. Используется как средство для доступа к ресурсу.
Семафор используется как счетчик, представляющий количество разрешений. Если значение счетчика больше 0, значит

Semaphore(int permits), где permits - кол-во разрешений.

Основные методы Семафоры. semaphore.acquire() - команда для получения разрешение от семафоры. semaphore.release() -
команда для возвращения разрешения семафоре.


---
<h2>* Что такое ExecutorService?</h2>
Появилась начиная с 5 версии Java. ExecutorService занимается управлением потоков. <br>
ExecutorService исполняет асинхронный код в одном или нескольких потоках. Инстанс ExecutorService делается через
конкретные имплементации:
<br>

        ExecutorService service = Executors.newFixedThreadPool(2);

---
<h2>* Что такое Atomic Integer</h2>
Есть пакет java.concurrent.atomic. Этот пакет содержит большое кол-во полезных классов для выполнения атомарных
операций. Atomic Integer - это атомарный класс.<br>
Что такое атомарная операция? <br>
Операция называется атомарной тогда, когда ее можно безопасно выполнять при параллельных вычислениях в нескольких
потоках, не используя при этом <b>ни блокировок, ни synchronized </b>. Атомные операции позволяют выполнять вычисления
для нескольких потоков без использования блокировок, таким образом производительность системы не падает. При
sycnhronized расчеты правильные, но очень сильно падает производительность системы, т.к. если метод занят одним потоком,
то другим потокам придется подождать пока освободится необходимый метод. То есть если необходимо изменить одну
переменную с помощью нескольких потоков, то лучше использовать атомарные классы.

Пример для Atomic Integer - один из атомарных классов.<br>
Бывают еще AtomicBoolean, AtomicLong и т.д.<br>

Пример счетчика с применением класса AtomicInteger:
<p>

    public class SafeCounterWithoutLock {

    private final AtomicInteger counter = new AtomicInteger(0);

    public int getValue() {
        return counter.get();
    }
    public void increment() {
        while(true) {
            int existingValue = getValue();
            int newValue = existingValue + 1;
            if(counter.compareAndSet(existingValue, newValue)) {
                return;
            }
        }
    }
    }

</p>

---
<h2>* ThreadPool - Пул нитей. Что это? </h2>

Есть класс ThreadPoolExecutor - это класс, который имееть в себе 2 компоненты: <br>

* Очередь задач, в которую можно добавлять задачи.
* Пул-нитей - которые эти задачи испольняют.

После исполнении задачи нити в пуле не уничтожаются, они переходят в спящий режим.
<br>Как работает ThreadPoolExecutor:

* При добавлении нового задания, оно помещается в конец очереди;
* Если очередь заполнена будет выкинуто исключение;
* Каждая нить послед выполнения задания берет из очереди следующее задание и выполняет его;
* Если задач в очереди нет, нить засыпает до их добавления.

<b>ПРИМЕР</b>
<p>

    ExecutorService service = Executors.newFixedThreadPool(2);
    for(int i = 0; i < 10; i++)
    {
    service.submit(new Runnable() {
    public void run()
    {
    // тут мы загружаем что-то тяжелое из интернета.
    }
    });
    }

</p>

<h2>* Интерфейс Callable</h2>
Интерфейс Callable больше подходит для параллельного выполнения небольших задач, чем Runnable and Thread. <br>
Этот интерфейс поддерживает пробрасывание исключений, а также позволяет узнавать результаты выполнения задач.
<br>
В отличие от Runnable в этом интерфейсе нужно переопределить метод call. <br>
Пример:<br>

    class ReverseString implements Callable<String>
    {
    String str;
    
    ReverseString(String str)
    {
    this.str = str;
    }
    
    public String call() throws Exception
    {
    StringBuilder builder = new StringBuilder(str);
    builder.reverse();
    return builder.toString();
    }
    }

Интерфейс Callable можно применять для ThreadPools.<br>
Привожу пример:<br>

    //1. Создаем ThreadPoolExecutor
    ExecutorService service = Executors.newFixedThreadPool(5);
    
    //2 помещаем в него задачу для выполнения
    Future<String> task = service.submit(new ReverseString("Amigo"));
    
    //3 ждем пока задача выполнится
    while(!task.isDone())
    {
    Thread.sleep(1);
    }
    
    //4 пробуем получить результат задачи
    //получим или результат или исключение, если оно было при выполнении задачи
    try
    {
    System.out.println("Развернутая строка : " + task.get());
    }
    catch (Exception ie)
    {
    ie.printStackTrace(System.err);
    }
    
    //5 останавливаем ThreadPool.
    service.shutdown();

Метод submit возвращает объект поддерживающий интерфейс Future. У интерфейса Future есть следующие методы:

* cancel (Останавливает задачу.);
* isCancelled (Возвращает true, если задача была остановлена.);
* isDone (Возвращает true, если выполнение задачи завершено.);
* get (Возвращает результат вызова метода call или кидает исключение, если оно было.);

---
<h2>* Class Future, FutureTask. CompletableFuture. Для чего нужны? Особенности. </h2>

---

# <a name="reflections"></a>

<h1>*** Java Reflections</h1>

---
<h2>* Reflection API. Что это? Где используется</h2>
Рефлексия (от позднелат. reflexio — обращение назад) — это механизм исследования данных о программе во время её
выполнения. Рефлексия позволяет исследовать информацию о полях, методах и конструкторах классов.

<i>Основной список того, что позволяет рефлексия: </i><br>

* Узнать/определить класс объекта;<br>
* Получить информацию о модификаторах класса, полях, методах, константах, конструкторах и суперклассах;<br>
* Выяснить, какие методы принадлежат реализуемому интерфейсу/интерфейсам;<br>
* Создать экземпляр класса, причем имя класса неизвестно до момента выполнения программы;<br>
* Получить и установить значение поля объекта по имени;<br>
* Вызвать метод объекта по имени.<br>

<p>
Рефлексия используется практически во всех современных технологиях Java. Сложно себе представить, могла бы Java, как платформа, достигнуть такого огромного распространения без рефлексии. Скорее всего не смогла бы. 
</p>
Пример рефлексии в след. директории: 

https://github.com/Azatick94/Java_Learning/tree/main/Basic_Java/src/main/java/learning_questions_answering/java_reflection


---

# <a name="java_ee"></a>

<h1>*** JAVA EE (ENTERPRISE EDITION)</h1>

---
<h2>* Что такое Сервлет? Что такое сервер? Что такое Tomcat?</h2>
Сервлет - это программа, работающая на сервере, которая взаимодействует с клиентами посредством принципа запрос-ответ.
Сервлет (второе определение) - java-компонент, позволяющий реализовать клиент-серверное взаимодействие с использованием
HTTP-протокола.
<br>
Сервлет архивируются в war-архивах. War-архив - аналог jar-архива. Содержит классы-сервлеты, а также web.xml-файл, в
котором описываются все используемые в архиве сервлеты и их маппинг (соответствие URl-ам).

Контейнер-сервлет - приложение-сервер, способное запускаться на определенном порту компьютера и поддерживающее работу
сервлетов. Принимает на вход war-архив, после чего делает его доступным на порту контейнера.
<br>
Apache Tomcat - это пример контейнера сервлетов. То есть он принимает запросы от клиента, отправляет запрос на обработку
в нужный сервлет и ответ отправляет обратно клиенту.

---
<h2>* В чем разница между jar и war. </h2>
Jar и War - это обычные архивы. <br>
<b>Jar</b> - Java Archive. Содержит файлы классов, ресурсы, зависимые библиотеки, и другие необходимые для приложения
файлы. Может содержать точку входа, и использоваться как цель для исполнения команды java.
<br>
<b>War</b> - Web Archive. Технически имеет ту же структуру, но другую роль – архив JavaEE web-компонента. Обычно
содержит jar-ы с реализацией, JSP, статические файлы фронт-энда, и мета-информацию для сервлет-контейнера (web.xml). В
основном используется как деплоймент web-приложения в сервлет-контейнер. С приходом Servlet API 3.0 и
embedded-контейнеров, всё больше становится принято запаковывать и web-компоненты в самодостаточные jar.

WAR и JAR собираются jar из JDK.

---
<h2>* JSP - Java Server Pages</h2>
JSP - это технология Java для создания динамических веб-страниц.

Что позволяет JSP:

* получать данные из веб-страницы в Java-код;
* отправлять данные из Java в веб-страницу;
* писать Java-код прямо в странице.

  JavaServerPages - технология, позволяющая разработчикам на Java избежать вывода содержимого страницы посредством
  использования PrintWriter-а в сервлете.<br>
  Вместо этого разработчик создает файл с расширением .jsp, этот файл может содержать html/css/JS/Java/JSTL-код. <br>
  JSP файл потом компилируется Jasper-ом, который уже выводит соответствующую информацию через PrintWriter.

<br>
JSTL тэги - это тэги, которые используются в jsp файле для упрощения java-кода в, написанного в jsp файле. 
<br>
JSTL - Java Server Tag Library. 


---
---
---

# <a name="spring"></a>

<h1>*** SPRING, SPRING BOOT, SPRING CORE, SPRING MVC, SPRING JPA и т.д. </h1>
<a href="https://habr.com/ru/post/350682/">1) Common questions</a><br>
<a href="https://habr.com/ru/post/490586/">2) Хорошая статья для начинающих</a><br>
<a href="https://spring.io/">3) Официальная станица spring.io</a><br>
<a href="https://habr.com/ru/post/222579/">3) Про способы конфигурирования Spring приложения.</a>

---
<h2>* Что такое REST API?</h2>

* https://boodet.online/reastapi
* https://habr.com/ru/company/oleg-bunin/blog/433322/

REST - Representational State Transfer. Отличительной особенностью сервисов REST является то, что они позволяют
наилучшим образом использовать протокол HTTP. REST - это архитектура, принципы построения распределенных гипермедиа
систем, того что другими словами называют World Wide Web.

REST - это прикладной программный интерфейс (API), который использует HTTP-запросы для получения, извлечения, размещения
и удаления данных. Аббревиатура переводится как "передача состояния представления".

<b>Принципы REST API</b>

* единый интерфейс (ресурсы должны быть представлены посредством URL-адреса и только с помощью базовых методов сетевого
  протокола: DELETE, PUT, CREATE, GET)
* разграничение клиента и сервера (на клиенте - пользовательский интерфейс, на стороне сервера - доступ к данным и т.д.)
* нет сохранения состояния (любое управление состоянием должно управляться через клиента). На сервере обязательно должно
  отсутствовать состояние, то есть, все, что приходит для ответа, приходит в запросе. Когда на сервере хранятся разные
  сессии, и в зависимости от сессии приходят разные ответы, это нарушение принципа REST.
* кэширование всегда разрешено
* многоуровневая система (REST API допускает архитектуру, которая состоит из нескольких уровней серверов)
* код предоставляется по запросу (В большинстве случаев сервер отправляет обратно статические представления ресурсов в
  формате XML или JSON. Однако при необходимости серверы могут отправлять исполняемый код непосредственно клиенту.)

---
<h2>* Что такое SOAP?</h2>

* https://ru.wikipedia.org/wiki/SOAP#:~:text=SOAP%20(%D0%BE%D1%82%20%D0%B0%D0%BD%D0%B3%D0%BB.,%D1%83%D0%B4%D0%B0%D0%BB%D1%91%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0%20%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%20(RPC)
* https://proselyte.net/tutorials/soap-tutorial/introduction/
* https://www.baeldung.com/jax-ws

SOAP (Simple Object Access Protocol) - протокол обмена структурированными сообщениями для связи в интернете. Протокол
используется для обмена произвольными сообщениями в формате XML.

Сообщения формата SOAP независимы от операционной системы и могут использоваться с различными протоколами связи (HTTP,
SMTP)


---
<h2>* DispatcherServlet</h2>
DispatcherServlet - его работа заключается в совершении запроса к Spring MVC Контроллеру.<br>
Но т.к контроллеров может быть много, перед тем как отправлять запрос к определ. контроллеру DispatcherServlet
обращается к Handler Mapping (Отображение обработчиков) для получение ответа к какому контроллеру обратиться.
<br>
DispatcherServlet можно конфигурировать в web.xml файле или напрямую через Java-код.

---
<h2>* Inversion of Control, Dependency Injection in Spring. Разница? В чем особенность. </h2>

<b>Inversion of control</b> (Инверсия контроля) - это принцип, в котором контроль флоу происходит не программистом, а
программой (Спрингом), Автоматическая загрузка бинов, связь между объектами, загрузка внешних сервисов, компонент и т.д.

<b>Dependency Injection</b> (Внедрение зависимостей) - это паттерн, который применяет принципл IOC. Это принцип
предоставляет доступ к объектам если эти объекты нужны другим объектам. Dependency Injection - это одна из реализаций
принципа IoC. Помимо DI бывают еще Factory Method, Service Locator.


---
<h2>* Spring Framework</h2>
Основные 3 компонента Spring Framework.

* Контекст приложения (Application Context) и Внедрение зависимостей (Dependency Injection);
* Удобрый и и эффективный доступ к БД (замена JDBC);
* Компонент для разработки Web - приложений (Spring MVC) - а также существуют множество других компонент (Spring
  Security, Spring Boot, Spring Webflow и т.д. )

Application Context - очень важная часть Spring Framework.

Spring конфигурировать можно следующими способами.

* Применение XML файла конфигураций (ApplicationContext.xml), но это уже старый способ;
* Java аннотаций и немного XML;
* Вся конфигурация на Java коде.

Особенностью SpringBoot является удобная работа с зависимостями Dependency Injection. Через xml файл или через аннотации
или другими способами можно описать объекты и их зависимости между собой, что при большом объеме классов уменьшает
кол-во написанного кода и упрощает жизнь программиста.

<b>Приведем способы внедрения зависимостей:</b>

* Через конструктор;
* Через setter;
* Можно внедрять ссылки или простые значения;
* Можем внедрять значения из внешнего файла;
* Через scope, init-method, destroy-method, factory method и т.д.
* Через XML, Java-аннотации или Java - код.
* Через Autowiring.

<b>Основные параметры bean-а :</b>

1) <b>id</b> - id/название бина;
2) <b>class</b> - класс бина, указываются относительный путь бина;
3) <b>scope</b> - Bean scope позволяет указывать какую ссылку хотим применять к бину. Виды scope: Singleton, Prototype,
   request, session, global-session. Singleton - используется когда у нашего бина нет изменяемых состояний. При каждом
   новом получении бина ссылка на объект один и тот же. Prototype - при создании каждого последующего бина создаются
   новые инстансы класса (то есть ссылки на бины отличаются).
4) <b>init-method</b> - метод, который будет вызываться при инициализации бина;
5) </b>destroy-method</b> - метод, который будет вызываться при остановке бина; Для init, destroy методов может быть
   любой модификатор доступа (public, protected, private)
   Эти методы не должны принимать на вход какие-либо аргументы. Для бинов со скоупом Prototype нельзя вызвать destroy.
6) <b>factory-method</b> - если объекты класса создаются фабричным методом, то можно определить этот параметр.

---
<h3>* Java Bean, что это, чем отличается от обычного объекта?<br></h3>

* https://ru.wikipedia.org/wiki/JavaBeans <br>
* https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly

<b>JavaBeans</b> — классы в языке Java, написанные по определённым правилам. Они используются для объединения нескольких
объектов в один (англ. bean — фасоль, кофейное зерно) для удобной передачи данных.

Требования к Java Бинам. <br>

* Бин должен имплементировать Serializable Interface.
* Должен быть public конструктор без аргументов. (No-arg constructor)
* Все параметры приватные. Доступ и присваиванию осуществляются через getters & setters.
* Класс должен иметь переопределенные методы equals(), hashCode() и toString()

---
<h2>* Аннотации в Spring Boot. Почему Конфигурирование через Аннотации лучше чем конфигурирование через Xml</h2>

<b>Преимущества:</b>

* Короче;
* Удобнее;
* Код более читабельный.
* Навигация лучше когда очень большое количество классов (В одном Xml файле найти определенный бин будет проблемно).

Виды аннотаций Spring-а:<br>

* <b>@Configuration</b> - аннотируем класс как конфигурационный класс.
* <b>@Bean</b> - создание бина в конфигурационном классе. <br>

* <b>@Component</b> - помечаем если хотим чтобы Spring создал бин из этого класса
* <b>@Autowired</b> - его можно использовать для конструктора, для setter-а или для поле (parameter initialization) (
  Спринг использует Reflection API). Через autowired происходит поиск подходящего объекта для инициализации текущего
  класса. <br>
  Если Autowired применен к конструктору, то Spring поймет что внедрять зависимости нужно через конструктор, <br>
  Если Autowired применен для метода (не важно как будет называться), то DI будет происходить через этот метод, <br>
  Если Autowired применен для параметра, то Spring используя Reflection будет производить DI. <br>

Все 3 способа для Autowired (через конструктор, метод, параметр) можно использовать, Главное - это стараться не
смешивать разные стили, лучше в проекте придерживаться одного выбранного.

* <b>@Qualifier</b> - уточнитель, используется когда для аннотации Autowired необходимо уточнить какой бин следует
  использовать для создания текущего бина. Qualifier для конструктора немного по-другому записывается. Пример ниже:<br>

@Autowired<br>
public MusicPlayer(@Qualifier("rockMusic") Music music1, @Qualifier("classicalMusic") Music music2) {<br>
this.music1 = music1;<br>
this.music2 = music2;<br>
}

* <b>@Scope</b>
  Можно указать как будет создаваться бин. "singleton" - один инстанс и в дальнейшем Spring будет всегда ссылаться на
  этот инстанс, "prototype" - с каждым новым созданием бина новый инстанс.

* <b>@Value</b> - позволяет внедрять значения свойств в bean-компонентах. Работает непосредственно с полями или по
  аргументам конструктора.

* <b>@PostConstruct</b>
  (Init метод - Spring вызывает метод перед созданием бина)

* <b>@PreDestroy</b>
  (Destroy - Spring вызывает этот метод при уничтожении бина)

* <b>@Configuration</b>
  Аннотация Configuration можно использовать вместо xml файла конфигурирования. То есть помечаем Java класс, который мы
  хотим использовать для конфигурирования Spring приложения.
* <b>@ComponentScan</b>
  Эта аннотация аналогична тэгу component-scan в xml файле. Эта аннотация необходима, чтобы указать директория всех Java
  классов для Аннотирования.
* <b>@PropertySource</b>
  Эта аннотация замена тэгу property-placeholder для получения данных из .properties файл

---
<h2>* Spring MVC</h2>
Spring MVC состоит из следующих компонент:

* обычные классы (Java классы, модели и прочее);
* набор HTML страниц. + JavaScript + CSS;
* Spring configuration (XML, Annotation, Java).

---
<h2>* Аннотация @Transactional в Spring. Что она делает?</h2>

Транза́кция (англ. transaction) — группа последовательных операций с базой данных, которая представляет собой логическую
единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и
независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого
эффекта. Транзакции обрабатываются транзакционными системами, в процессе работы которых создаётся история транзакций.

Приведем пример Сервиса.

    import org.springframework.stereotype.Component;
    import org.springframework.transaction.annotation.Transactional;
    
    @Component
    public class UserService {
    
        @Transactional           // (2)
        public User activateUser(Integer id) {  // (1)
            // execute some sql
            // send an event
            // send an email
        }
    }

Здесь написан метод activateUser, который при вызове должен выполнить некоторый SQL-запрос, чтобы обновить состояние
пользователя в базе данных, возможно отправить сообщение электронной почты или событие обмена сообщениями.<br>
@Transactional сигнализирует Spring, что для работы этого метода необходимо открыть соединение с БД / транзакция и что
указанная транзакция также должна быть зафиксирована в конце. И Spring должна сделать это. С этой целью Spring создает
прокси вокруг Сервиса, который будет транзакционным.

---
<h2>* Spring @PropertySources Аннотация</h2>
Эта аннотация позволяет указывать директорию откуда доставать .properties для Spring приложения.
<br>
Пример:

    import org.springframework.context.annotation.PropertySources;
    import org.springframework.context.annotation.PropertySource;
    
    @Configuration
    @PropertySources(
    {@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties"),
    @PropertySource("file://myFolder/app-production.properties")})
    public class MyApplicationContextConfiguration {
    // your beans
    }

---
<h2>* Виды инициализаторов в Spring Boot?</h2>

* Spring Boot DevTools;
* Lombok;
* Spring Web (Spring MVC, Использует Tomcat как встроенный контейнер.)
* Spring Reactive Web
* Spring Session
* Spring HATEOS etc

Templates:

* Thymeleaf
* Mustache
* Groovy Templates etc

* Spring Security etc

* JDBC API
* Spring DATA JPA
* Spring DATA JDBC etc

IO:

* Spring Batch
* Validation
* Java Mail Sender etc

OPS:

* Spring Boot Actuator

OBSERVABILITY

* DATADOG
* Influx
* Zipkin Client

TESTING

SPRING CLOUD

---
<h2>* Spring Boot Actuator. Что это?</h2>

* https://www.javatpoint.com/spring-boot-actuator#:~:text=Spring%20Boot%20Actuator%20is%20a,place%20where%20the%20resources%20live)
  .

Это проект в Spring Boot. Включает в себя фичи для мониторинга и управления Spring Boot приложением.

---
<h2>* Что такое BeanPostProcessor</h2>

# TODO

--- 
<h2>* Жизненный цикл бина. </h2>

* https://medium.com/swlh/the-lifecycle-of-spring-beans-b0edb8936189

Этапы жизненного цикла бина:

1) <b>Определение Бина</b>. Бин определяются с помощью Java Аннотаций или с помощью XML конфигурации.
2) <b>Создание Бина и его инициализация</b>. После создании и инициализации Бин загружается в ApplicationContext.
3) <b>Распространение свойств Бина</b>. Контейнер Спринга создаст для бина <i>id, scope, default values</i>
   используя <b>Bean Definition</b>.
4) <b>Post-Initialization</b>. С помощью спринга выполняется дополнительная логика преинициализации Бинов. Для
   пост-инициализации используется аннотация @PostConstruct.
   <br>
   Пример:

   @Component class Foo { @PostConstruct public void postConstructMethod() { System.out.println("Spring Bean Post
   Construct Annotation Method "); }

5) <b>Бин готов к работе</b>. Бин создан и все зависимости внедрены.
6) <b>Pre-destroy</b>. Выполнение кастомной логики перед уничтожением Бина.

   @Component class Foo { @PreDestroy public void preDestroy() { System.out.println("Spring Bean Pre Destroy Annotation
   Method"); } }

7) <b>Уничтожение Бина</b>. Бин уничтожен и удален из памяти виртуальной машины.

---
<h2>* АОП - Аспектно-ориентированное программирование. Особенности</h2>

Парадигма программирования, основанная на идее разделения функциональности для улучшения разбиения программы на модули.
<br>
АОП предназначен для решения сквозных задач, которые могут представлять собой любой код, многократно повторяющийся
разными методами, который нельзя полностью структурировать в отдельный модуль. Примеры АОП -  <b>логирование</b>.

Преимущества АОП логирования по сравнению с обычной вставкой для логирования:

* Код для логирования легко внедрять и удалять.
* Весь исходный код для логирования хранится в одном месте и не нужно находить вручную все места использования.
* При удалении аспекта из конфигурации можно быть абсолютно уверенным, что весь код трассировки удален и ничего не
  пропущено.
* Аспекты - это вынесенный отдельный код, который можно многократно переиспользовать и улучшать.

---
<h2>* Виды внедрения зависимостей в Spring.</h2>
Зависимости можно внедрять через:<br>

* Внедрение через поля - Field Injection;
* Через setter - setter Injection;
* Через Конструктор - Constructor Injection.

---
<h2>* Как генерировать JSON/XML (представления) с помощью Spring Web MVC. </h2>
Коротко - нужно использовать аннотацию @ResponseBody. <br>
Пример: <br>

    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.ResponseBody;
    
    @Controller
    public class HealthController {
    
        @GetMapping("/health")
        @ResponseBody // (1)
        public HealthStatus health() {
            return new HealthStatus(); // (2)
        }
    }

---
<h2>* Разница между @Component и @ComponentScan?</h2>

@Component и @ComponentScan предназначены для разных целей.

@Component помечает класс в качестве кандидата для создания Spring бина. @ComponentScan указывает где Spring искать
классы, помеченные аннотацией @Component или его производной

---
<h2>* В чем разница между @Bean и @Component.</h2>
@Bean используется в конфигурационных классах Spring. Он используется для непосредственного создания бина.

@Component используется со всеми классами, которыми должен управлять Spring. Когда Spring видит класс с @Component,
Spring определяет этот класс как кандидата для создания bean.


---
<h2>* Разница между @Component, @Service и @Repository аннотациями?</h2>
Все они определяют бины Spring. Однако между ними всё же есть разница.

@Component — универсальный компонент @Repository — компонент, который предназначен для хранения, извлечения и поиска.
Как правило, используется для работы с базами данных. @Service — фасад для некоторой бизнес логики

Пользовательские аннотации, производные от @Component, могут добавлять специальную логику в бинах. Например, бины,
получившиеся при помощи @Repository, дополнительно имеют обработку для JDBC Exception

---
<h2>* Разница между web.xml и the Spring Context - servlet.xml</h2>
web.xml — Метаданные и конфигурация любого веб-приложения, совместимого с Java EE. Java EE стандарт для веб-приложений.

servlet.xml — файл конфигурации, специфичный для Spring Framework.


---
<h2>* В чем разница между classPathXmlApplicationContext и annotationConfigApplicationContext?</h2>
classPathXmlApplicationContext — если вы хотите инициализировать контекст Spring при помощи xml

annotationConfigApplicationContext — если вы хотите инициализировать контекст Spring при помощи конфигурационного класса
java


---
<h2>* Как вы решаете какой бин инжектить, если у вас несколько подходящих бинов. Расскажите о @Primary и
@Qualifier?</h2>
Если есть бин, который вы предпочитаете большую часть времени по сравнению с другими, то используйте @Primary, и
используйте @Qualifier для нестандартных сценариев.

Если все бины имеют одинаковый приоритет, мы всегда будем использовать @Qualifier

Если бин надо выбрать во время исполнения программы, то эти аннотации вам не подойдут. Вам надо в конфигурационном
классе создать метод, пометить его аннотацией @Bean, и вернуть им требуемый бин.

---
<h2>* В чем разница между model.put() и model.addAttribute()?</h2>
Метод addAttribute отделяет нас от работы с базовой структурой hashmap. По сути addAttribute это обертка над put, где
делается дополнительная проверка на null. Метод addAttribute в отличии от put возвращает modelmap. model.addAttribute(
“attribute1”,”value1”).addAttribute(“attribute2”,”value2”);

---
<h2>* Требования к Persistence class в Hibernate. </h2>

* Наличие конструктора без аргументов.
* Наличие id атрибута для Primary Key.
* Наличие геттеров и сеттеров.
* Hibernate использует концепцию Проксей (Proxies). Поэтому атрибуты и класс не должны быть финальными.

---
<h2>* Метод persist в Hibernate. </h2>
Метод persist()  делает сразу огромное количество вещей:

* Сохраняет данные сущности в базу. Или, возможно, запоминает, что надо бы их сохранить в базу потом.
* Делает всё тоже самое для связанных сущностей, у которых выставлено каскадирование CascadeType.PERSIST или
  CascadeType.ALL.
* Самое главное — берёт сущность под свою опеку и переводит её в состояние «управляемая» (managed)

---
<h2>* Преимущества Hibernate. </h2>

* Устраняет множество повторяющегося кода, который постоянно преследует при работа с JDBC. Это позволяет сфокусироваться
  на бизнес логике.
* Предоставляет собственный мощный язык запросов (HQL - Hibernate Query Language), который похож на SQL.
* Поддерживает ленивую инициализацию используя proxy объекты.
* Поддерживает разные уровни cache, что также повышает производительность.
* Hibernate может использовать чистый SQL, а значит поддерживает возможность оптимизации запросов и работы с любым
  сторонним вендором БД.
* Hibernate позволяет генерировать таблицы в базе данных.

---
<h2>* SessionFactory Hibernate? Что это?</h2>

* https://docs.jboss.org/hibernate/orm/3.5/javadocs/org/hibernate/Session.html

Дословно Фабрика Сессий. С помощью фабрики Сессий можно создать Сессию - Session. А Sesssion - это интерфейс между Java
приложением и Hibernate.  <br>



---
<h2>* Что такое Proxy в Spring? </h2>
Это класс, который обертывает ваш класс. Цель состоит в том, чтобы расширить свой класс дополнительными функциональными
возможностями, например, добавить к нему транзакционное поведение или ввести некоторые ресурсы.

--- 
<h2>* Что такое кэширование. Hibernate cache. Как его использовать.</h2>

1) https://www.baeldung.com/spring-cache-tutorial

<b>Что такое кэширование? </b><br>
В сфере вычислительной обработки данных кэш – это высокоскоростной уровень хранения, на котором требуемый набор данных,
как правило, временного характера. Доступ к данным на этом уровне осуществляется значительно быстрее, чем к основному
месту их хранения. С помощью кэширования становится возможным эффективное повторное использование ранее полученных или
вычисленных данных.

Данные в кэше обычно хранятся на устройстве с быстрым доступом, таком как ОЗУ (оперативное запоминающее устройство), и
могут использоваться совместно с программными компонентами. Основная функция кэша – ускорение процесса извлечения
данных. Он избавляет от необходимости обращаться к менее скоростному базовому уровню хранения.

Небольшой объем памяти кэша компенсируется высокой скоростью доступа. В кэше обычно хранится только требуемый набор
данных, причем временно, в отличие от баз данных, где данные обычно хранятся полностью и постоянно.

Hibernate cache - имеет 3 уровня кеширования.

* Кеш первого уровня (First-level cache);
* Кеш второго уровня (Second-level cache);
* Кеш запросов (Query cache);

@EnableCaching - для использования кэширования необходимо использовать эту аннотация на любом конфигурационном классе
@Cacheable - Самый простой способ кэширования метода. @Cacheable("user") - в качестве параметра нужно написать название
кэша, где нужно искать метод. @CacheEvict - Используется для кэширования редко используемых запросов. В случае
заполнения кэша, кэш будет чиститься от методов в этой аннотацией. @CachePut - Используется для обновления данных,

---
<h2>* Lazy loading в Spring-е? Что это, особенности?</h2>

* https://www.geeksforgeeks.org/lazy-loading-design-pattern/

Lazy Loading - это паттерн разработки, это процесс инициализации класса тогда, когда он нужен. Простыми словами это
паттерн, когда инициализация объекта происходит только тогда, когда это нужно, но не раньше с целью улучшения
перформанса приложения. Этот паттерн важен, когда стоимость инициализации объекта высока и использование объекта
нечастое.

Пример: <br>
Предположим, что у нас есть приложение, в котором используется объект Company. Этот объект также содержит список
Работников этой Компании List<Employee>. Этих работников может быть огромное количество (1000+ например). То есть чтобы
загрузить класс Company придется подождать пока загрузятся также еще 1000 сотрудников. Это очень долгий процесс. К тому
же возможно эти 1000 работников могут и не пригодиться. Для таких задач идеально подойдет Lazy Loading паттерн,
Работники будут загружаться по мере необходимости.

---

# <a name="testing"></a>

<h1>*** Тестирование</h1>

---
<h2>* TDD - Test Driver Development</h2>

* https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5

Разработка через тестирование. Разработка через тестирование (англ. test-driven development, TDD) — техника разработки
программного обеспечения, которая основывается на повторении очень коротких циклов разработки: сначала пишется тест,
покрывающий желаемое изменение, затем пишется код, который позволит пройти тест, и под конец проводится рефакторинг
нового кода к соответствующим стандартам.

---
<h2>* Какие бывают тестирования? Типы, отличия и т.д?</h2>
<p>
<a href="https://habr.com/ru/post/358950/">Ссылка на отличную статью про тестирование</a>
</p>

* Блочное(модульное) тестирование (Unit testing) - тестирование одного модуля в изоляции.<br>
  Модульные тесты имеют максимально узкую область среди всех тестов в наборе тестов. Количество юнит-тестов в наборе
  значительно превышает количество любых других тестов.<br>
  Когда дело доходит до написания юнит-тестов, есть тонкая черта: они должны гарантировать, что проверены все
  нетривиальные пути кода, включая дефолтный сценарий и пограничные ситуации. В то же время они не должны быть слишком
  тесно привязаны к реализации.

* Интеграционное тестирование - тестирование группы взаимодействующих модулей. <br>
  Есть определение — это тестирование взаимодействия нескольких классов, выполняющих вместе какую-то работу. Проверка
  взаимодействия сервиса с базой данных, тестирование независимых REST API в которые мы делаем запросы.

* Системное тестирование - тестирование системы в целом, тестирование пользовательского интерфейса.

Какие еще подтипы бывают:

* Регрессионное тестирование (используется для проверки того, не влияют ли новые фичи или исправленные баги на
  существующий функционал приложения и не появляются ли старые баги.)
* Функциональное тестирование (проверка соответствия части приложения требованиям, заявленным в спецификациях,
  юзерсторях и т. д.)
* Нагрузочное тестирование (load testing, для проверки устойчивости системы при стандартных нагрузках и для нахождения
  максимально возможного пика, при котором приложение работает корректно.);
* Стресс тестирование(stress testing, для проверки работоспособности приложения при нестандартных нагрузках и для
  определения максимально возможного пика, при котором система не упадёт.)
* Тестирование безопасности;
* Юзабилити тестирование;
* Ручное тестирование;
* Сквозные тесты;
* Приемочные тесты;

---
<h2>* TDD, BDD testing? Отличия, особенности. </h2>

* https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5
* https://ru.wikipedia.org/wiki/BDD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

<b>TDD - Test Driven Development</b> <br>
<b>BDD - Behavior Driven Development</b> <br>

TDD - суть методологии в том, что в первую очередь пишутся тесты, а потом под эти тесты разрабатывается функционал. <br>

BDD - это расширенная (дополненная) версия TDD методологии. Особенность BDD в том, что в начале пишется на
человекоподобном скриптовом языке тестовый сценарий. Этот язык очень простой, очень понятный, благодаря этому многие
нетехнические специалисты также могут участвовать в этапе тестирования. <br>

<i>Список инструментов, поддерживающих BDD методологию</i>:

* Cucumber
* Easy B
* JDave
* JBehave
* SpecFlow и т.д.

---
<h2>* Функциональное тестирование. Что это?</h2>
Функциональное тестирование – один из видов тестирования, направленного на проверку соответствий функциональных
требований ПО к его реальным характеристикам.<br>
Основной задачей функционального тестирования является подтверждение того, что разрабатываемый программный продукт
обладает всем функционалом, требуемым заказчиком.

---
<h2>* Smoke testing. Что это?</h2>

* https://ru.wikipedia.org/wiki/Smoke_test

<b> Smoke test (дымовое тестирование)</b> - минимальный набор тестов для выявления явных ошибок в программном обеспечении.
Обычно этот этап проходит перед более глубоким тестированием. Если в результате smoke-тестирования обнаружены
критические ошибки, то проводить более глубокое тестирование ПО нет смысла. Smoke-тестирование сокращает время на тестирование и
тем самым экономит деньги и время.

Вот список основных преимуществ Smoke-тестирования:

* легко выполнить
* дефекты будут определены на ранней стадии
* улучшает качество системы
* минимизация рисков
* уменьшает затраты на тестирование и время тестирования
* легко найти критические ошибки и легко их исправить

---
<h2>* Sanity Test</h2>
Санитарное тестирование - это узконаправленное тестирование, направленное для подтверждения правильной работы конкретной
функции согласно заявленным требованиям. Является подмножеством регрессионного тестирования. Используется для
определения работоспособности определенной части приложения после изменений произведенных в ней или окружающей среде.
Обычно выполняется вручную.

В отличие от дымового <b>(Smoke testing)</b>, санитарное тестирование <b>(Sanity testing)</b> направлено вглубь
проверяемой функции, в то время как дымовое направлено вширь, для покрытия тестами как можно большего функционала в
кратчайшие сроки.

---
<h2>* Что такое Mock? Фреймворк Mockito? Особенности тестирования через Mock.</h2>

# TODO

* https://www.baeldung.com/mockito-annotations

---
<h2>* Фреймворк Cucumber</h2>

* https://cucumber.io
* https://cucumber.io/docs/guides/10-minute-tutorial/
* https://github.com/Azatick94/Java_Learning/tree/main/Cucumber_Google_Search (Cucumber Project Example)
* https://github.com/Azatick94/awesome-bdd-with-cucumber (Sample Cucumber Project Setup)

### Статья с примерами написания Gherkin Feature тестовых сценариев на русском языке.

* https://habr.com/ru/post/332754/

### Полезная серия из статей про Cucumber

* https://medium.com/agile-vision/behavior-driven-development-bdd-software-testing-in-agile-environments-d5327c0f9e2d
* https://medium.com/agile-vision/starting-with-bdd-for-collaborative-development-in-agile-environments-5fb034078b3c
* https://medium.com/agile-vision/cucumber-bdd-part-2-creating-a-sample-java-project-with-cucumber-testng-and-maven-127a1053c180
* https://github.com/ashenwgt/awesome-bdd-with-cucumber

Cucumber - это BDD FrameWork, который использует легко-понятный для бизнеса язык Gherkin для написания тестовых
сценариев.

Тестовый сценарий выглядит следующим образом:

    Feature: feature name
    As a [role]
    I want [feature]
    So that [benefit/business reason]
    
    Scenario: title
    Given context
    When event
    Then outcome
    And/But more of the same ...
    
    Scenario Outline: title
    Given .... <placeholder 1> .....
    When .... <placeholder 2> ...
    Then ... <placeholder 3> ...
    
    Examples:
    | placeholder 1 | placeholder 2 | placeholder 3 |
    |  value        |   value       |  value        |
    |  value        |   value       |  value        |

<b>Feature</b> - описывают функционал, который требует бизнес, здесь нужно указать наименование и кратко описать, что он
должен выполнять. <br>
<b>Scenario</b> - здесь описывается тестовый сценарий.  <br>
<b>Examples</b> - примеры входных данных для тестирования. <br>

---
<h2>* JUnit Framework для тестирования. </h2>
<a href="https://junit.org/junit5/">Link for Junit Framework</a>

---
<h2>* Отличие mock от stub</h2>

* https://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub

<b>Stub</b> - это к примеру класс, где будет описано то ожидаемое поведение от методов этого класса. То есть фейки
методов. Этот Stub обычно написан за пределами теста.
<b>Mock</b> - является частью теста, где указывается поведение класса/сервиса/чего угодно, а также описывается ожидаемый
результат. Наличие ожидаемого результата является одним из основных различий между Stub vs Mock.

---
<h2>* Selenium Framework for testing. </h2>

Это фреймворк для автоматизированного тестирования веб-приложений.

* https://www.selenium.dev/downloads/
* https://www.youtube.com/watch?v=dbzc9UbFZt8
* https://www.youtube.com/watch?v=P-vureOnDWY (talk about Selenium & Selenide)

### Simple example of Selenium Framework test

* https://github.com/Azatick94/Java_Learning/tree/main/Selenium_FrameWork

### Advanced way of Selenium Framework test

* https://github.com/Azatick94/Java_Learning/tree/main/Selenium_New_Approach

### Selenide Introduction

# TODO

---
<h2>* Maven - инструмент для сборки Java проектов. Вопросы. </h2>
<h3>Основные фазы сборки: </h3>

* compile - компилирование проекта;
* test - тестирование с помощью JUnit тестов;
* package - создание jar файла или war, ear в зависимости от типа проекта;
* integration-test - запуск интеграционных тестов;
* install - копирование jar (war, ear) в локальный репозиторий;
* deploy - публикация файла в удалённый репозиторий.

Плагины - это способ расширить функциональность Maven в больших диапазонах.

Properties. Build. Profiles.

Разница между package vs install:

* https://stackoverflow.com/questions/16602017/how-are-mvn-clean-package-and-mvn-clean-install-different

---
<h2>* Maven Scopes - область действия зависимостей</h2>

Область действия зависимости scope определяет этап жизненного цикла проекта, в котором эта зависимость будет
использоваться.

В Maven бывает 6 типов scopes:<br>

* <b>compile</b> (область по умолчанию. Используется если scope не определен. Compile зависимости доступны во всех
  classpath проекта);
* <b>provided</b> (очень похоже на compile, но эта зависимость в сборку не попадает. Предполагается, что зависимость (
  артефакт) уже присутствует в JDK или в WEB-контейнере. Эта область доступна только на этапах компиляции и тестирования
  и не является транзитивной);
* <b>runtime</b> (зависимость не требуется при компиляции приложения, только в фазе запуска приложения);
* <b>test</b> (зависимость не нужна для нормальной работы приложения. Зависимость будет доступна только для тестирования
  приложения);
* <b>system</b> (область похожа на provided за исключением того, что необходимо определить физическое расположение
  артефакта на диске. Артефакт с этой областью видимости maven не ищет в репозитории);
* <b>import</b> (эта область используется в зависимости секции <dependencyManagement> при сложных связях (см.
  dependencyManagement));

---

# <a name="design_patterns"></a>

<h1>*** Паттерны Проектирования</h1>

---
<h2>* Паттерн Стратегия. </h2>
<a href="https://refactoring.guru/ru/design-patterns/strategy">Полезная ссылка</a>
<br>

Стратегия - это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый
из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

<b>Пример из жизни:</b><br>
Вам нужно добраться до аэропорта. Можно доехать на автобусе, такси или велосипеде. Здесь вид транспорта является
стратегией. Вы выбираете конкретную стратегию в зависимости от контекста — наличия денег или времени до отлёта.

---
<h2>* Паттерн Adapter</h2>

* https://www.baeldung.com/java-adapter-pattern
* https://javarush.ru/groups/posts/2139-pattern-proektirovanija-adapter

Паттерн "Адаптер" связывает существующий класс с новый интерфейсом, чтобы он мог быть связан с интерфейсом клиента.
Встроенные Адаптеры в Java:

* java.util.Arrays#asList()
* java.util.Collections#list()

Пример: <br>
"Предположим, что у нас есть приложение, который был создать для USA и суть программы в том, что он возвращает топ
дорогих машин отсортированных по скорости. (Мили/час). Теперь мы хотим использовать это приложение в Великобритании. Но
теперь нужно, чтобы приложение выводила результаты в единицах Км/час. Для выполнения этого условия необходимо
использовать Паттерн Адаптер".
<br>

<b>Создадим Интерфейс Movable</b>

    public interface Movable {
    // returns speed in MPH
    double getSpeed();
    }

<b>Теперь реализация этого Интерфейса</b>

    public class BugattiVeyron implements Movable {
        @Override
        public double getSpeed() {
            return 268;
        }
    }

<b>Теперь создадим Интерфейс-Адаптера</b>

    public interface MovableAdapter {
    // returns speed in KM/H
    double getSpeed();
    }

<b>И теперь непосредственно реализация этого Интерфейса-Адаптера</b>

    public class MovableAdapterImpl implements MovableAdapter {
        // getting instance of Movable Interface Class 
        private Movable luxuryCars;
    
        // standard constructors
    
        @Override
        public double getSpeed() {
            return convertMPHtoKMPH(luxuryCars.getSpeed());
        }
        
        private double convertMPHtoKMPH(double mph) {
            return mph * 1.60934;
        }
    }

<b>Результат Тестирования</b>

    @Test
    public void whenConvertingMPHToKMPH_thenSuccessfullyConverted() {
    Movable bugattiVeyron = new BugattiVeyron();
    MovableAdapter bugattiVeyronAdapter = new MovableAdapterImpl(bugattiVeyron);
    
        assertEquals(bugattiVeyronAdapter.getSpeed(), 431.30312, 0.00001);
    }

---
<h2>* Паттерн Decorator</h2>

* https://pro-java.ru/patterny-proektirovaniya-java/realizaciya-patterna-dekorator-v-prostom-kode-java/

Декоратор — это структурный паттерн, который позволяет добавлять объектам новые поведения на лету, помещая их в
объекты-обёртки.

Пример:<br>
Будет пример POS-системы пиццерии.

<b>Создаем интерфейс Order.</b>

    public interface Order {
    
        public double getPrice();
        public String getLabel();
    
    }

<b>Класс Пицца, имплементирует Интерфейс Order. Это целевой объект для декорирования </b>

    public class Pizza implements Order {
    
        private String label;
        private double price;
      
        public Pizza(String label, double price) {
    
            this.label = label;
            this.price = price;
        }
    
        public double getPrice() {
            return this.price;
        }
    
        public String getLabel() {
            return this.label;
        }
    
    }

<b>Теперь создадим объект класс Pizza </b>

    Order fourSeasonsPizza = new Pizza("Четыре сезона", 10);

<b>Теперь мы хотим добавить к пицце различные начинки. Для этого нужно будет использовать декоратор. Создадим
Абстрактный класс Extra. </b>

    public abstract class Extra implements Order {
    
        protected Order order;
        protected String label;
        protected double price;
    
        // All Args Construct
    
        public abstract double getPrice();
        public String getLabel() { return order.getLabel() + ", " + this.label; }
    }

<b>И теперь классы, реализующие Абстрактный класс Extra. </b>

    public class RegularExtra extends Extra {
        public RegularExtra(String label, double price, Order order) {
            super(label, price, order);
        }
        public Double getPrice() {
            return this.price + order.getPrice();
        }
    }

    public class NoCostExtra extends Extra {
        public NoCostExtra(String label, double price, Order order) {
            super(label, price, order);
        }
        public Double getPrice() {
            return order.getPrice();
        }
    }

    public class DoubleExtra extends Extra {
        public DoubleExtra(String label, double price, Order order) {
            super(label, price, order);
        }
        public Double getPrice() {
            return (this.price * 2) + order.getPrice();
        }
        public String getLabel() {
            return order.getLabel() + ", Double " + this.label;
        }
    }

<b>А теперь можно протестировать.</b>

    Order fourSeasonsPizza = new Pizza("Four Seasons Pizza", 10);
    fourSeasonsPizza = new RegularExtra("Pepperoni", 4, fourSeasonsPizza);
    fourSeasonsPizza = new DoubleExtra("Mozzarella", 2, fourSeasonsPizza);
    fourSeasonsPizza = new NoCostExtra("Chili", 2, fourSeasonsPizza);
    
    System.out.println(fourSeasonsPizza.getPrice());
    System.out.println(fourSeasonsPizza.getLabel());

---
<h2>* Паттерн SOLID</h2>

* https://javarush.ru/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java
* https://www.baeldung.com/solid-principles

1. Single Responsibility
2. Open/Closed
3. Liskov Substitution
4. Interface Segregation
5. Dependency Injection

1) <b>Single Responsibility Principle </b>(Принцип единственной ответственности). На каждый объект возлагается одна
   обязанность, полностью инкапсулированная в класс.

Преимущества: <br>

* Проще тестировать класс с единственной ответственностью
* Меньше зависимостей
* Проще искать маленькие, хорошо-структурированные классы

2) <b>Open-Closed Principle </b>(Принцип открытости/закрытости). Это означает, что должна быть возможность изменять
   внешнее поведение класса, не внося физические изменения в сам класс.
   <b>Open For Extension, Closed For Modification.</b>  
   Следуя этой концепции, мы не изменяет существующий код, тем самым не порождаем новые баги. Конечно единственное
   исключение - фикс багов.

Пример:

Создадим класс Гитара:

    public class Guitar {
    
        private String make;
        private String model;
        private int volume;
        //Constructors, getters & setters
    }

Запускаем приложение, и вроде всех все устраивает. Но через некоторое время, мы решили что обычная гитара как-то скучно
и мы решили туда еще добавить дополнительный атрибут flameColor Вместо того, чтобы лезть в исходный класс и изменять
его, лучше всего создать класс наследник SuperCoolGuitarWithFlames.

    public class SuperCoolGuitarWithFlames extends Guitar {
    
        private String flameColor;
        //constructor, getters + setters
    }

Таким образом мы будем уверены, что мы никак не повлияем на наше приложение и не порождаем новые баги.

3) <b>Liskov's Substitution Principle </b>(Принцип подстановки Барбары Лисков). Его можно описать так: объекты в
   программе можно заменить их наследниками без изменения свойств программы.

Один из наиболее сложно воспринимаемых принципов. Этот принцип расширяет 2 принцип (Open-Closed Principle). <br>
Этот принцип гласит, что объекты Класса-Родителя (SuperClass) должны быть заменяемы объектами из Класс-Наследника. Для
этого необходимо, чтобы объекты наследника имели аналогичное поведению объекта Класса Родителя. Это достигается
следующими правилами: <br>

* Переопределенный метод Класса-Наследника должен принимать те же входные параметры, что и в Классе-Родителя.
* То же самое касается return-а. Тип return-а должен быть одинаковым.

4) <b>Interface Segregation Principle </b>(Принцип разделения интерфейса). Принцип разделения интерфейсов говорит о том,
   что слишком «толстые» интерфейсы необходимо разделять на более мелкие и специфические, чтобы клиенты мелких
   интерфейсов знали только о методах, необходимых в работе. В итоге, при изменении метода интерфейса не должны меняться
   клиенты, которые этот метод не используют.

Пример:

Представим зоопарк и клетку с медведем:

    public interface BearKeeper {
    void washTheBear();
    void feedTheBear();
    void petTheBear();
    }

В этом интерфейсе описаны три метода: помыть медведя, покормить и обнять медведя. Однако мы все в курсе, что однимать
медведя очень опасное занятие и мы не хотим этот метод в своем классе определять. В данном случае самый правильный путь

- разбить наш интерфейс на 3 интерфейса и имплементить те, которые нам нужны.

  public interface BearCleaner { void washTheBear(); }

  public interface BearFeeder { void feedTheBear(); }

  public interface BearPetter { void petTheBear(); }

Таким образом мы используем только 2 интерфейса.

    public class BearCarer implements BearCleaner, BearFeeder {
    
        public void washTheBear() {
            //I think we missed a spot...
        }
        public void feedTheBear() {
            //Tuna Tuesdays...
        }
    }

Обнимашки с медведем будут делать другие люди:

    public class CrazyPerson implements BearPetter {
    
        public void petTheBear() {
            //Good luck with that!
        }
    }

5) <b>Dependency Inversion Principle </b>(Принцип инверсии зависимостей). Модули верхнего уровня не зависят от модулей
   нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Пример старого компьютера на Windows98

    public class Windows98Machine {}

Теперь к процессору добавим Монитор и Клавиатуру.

    public class Windows98Machine {
    
        private final StandardKeyboard keyboard;
        private final Monitor monitor;
    
        public Windows98Machine() {
            monitor = new Monitor();
            keyboard = new StandardKeyboard();
        }
    
    }

Однако этот подход плохой. Т.к мы связываем 3 класса между собой. Самый лучший способ через конструктор принимать классы
StandardKeyboard и Монитор. А лучше вместо StandartKeybord использовать интерфейс Keybord.

    public interface Keyboard { }
    public class Windows98Machine{
    
        private final Keyboard keyboard;
        private final Monitor monitor;
    
        public Windows98Machine(Keyboard keyboard, Monitor monitor) {
            this.keyboard = keyboard;
            this.monitor = monitor;
        }
    }

    public class StandardKeyboard implements Keyboard { }

Теперь наши классы разделены и общаются через абстракцию Keybord. Если нам нужно, мы можем спокойно использовать другую
реализацию клавиатуры. То же самое и для Монитора.

---
<h2>* Front Controller. (Контроллер входа). </h2>
<a href="http://design-pattern.ru/patterns/front-controller.html">LINK</a><br>
Паттерн <b>Front Controller</b> объединяет всю обработку запросов, пропуская запросы через единственный
объект-обработчик. Этот объект содержит общую логику поведения, которая может быть изменена в реальном времени при
помощи декораторов. После обработки запроса контроллер обращается к конкретному объекту для отработки конкретного
поведения.

---
<h2>* Паттерн проектирования DRY</h2>
DRY - Don't Repeat Yourself. <br>
Этот принцип заключается в том, что нужно избегать повторений одного и того же кода. Лучше использовать универсальные
свойства и функции.

---
<h2>* Паттерн проектирования KISS</h2>
KISS - Keep It Simple. <br>
Смысл этого принципа программирования заключается в том, что стоит делать максимально простую и понятную архитектуру,
применять шаблоны проектирования и не изобретать велосипед.

--- 
<h2>SOA принципы</h2>
SOA - Service-Oriented Architecture (Сервис-Ориентированная Архитектура) <br>

* https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%80%D0%B2%D0%B8%D1%81-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0
* https://dic.academic.ru/dic.nsf/ruwiki/1331397

SOA - это архитектурный паттерн, модульный подход к разработке ПО, основанный на использовании распределенных,
слабосвязанных компонентов, оснащенных стандартизированными интерфейсами для взаимодействия по стандартизированным
протоколам.

Программные комплексы, разработанные в соответствии с сервис-ориентированной архитектурой, обычно реализуются как набор
веб-служб, взаимодействующих по протоколу SOAP, но существуют и другие реализации (например, на базе jini, CORBA, на
основе REST).










